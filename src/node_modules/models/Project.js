import throttle from 'lodash.throttle'

import Frame from './Frame'

import createGif from 'lib/createGif'

import {
  RESOLUTION,
  PIXEL_SIZE,
  DEFAULT_COLORS,
  MIN_FRAME_RATE,
  MAX_FRAME_RATE,
  DEFAULT_FRAME_RATE
} from 'config/constants'

const SIZE = RESOLUTION * PIXEL_SIZE

const defaultProps = {
  title: 'Project 1',
  frameId: 1,
  color: DEFAULT_COLORS.black,
  frameIndex: 0,
  frameRate: DEFAULT_FRAME_RATE,
  showUnderlay: true,
  width: SIZE,
  height: SIZE,
  get colors() { return Object.values(DEFAULT_COLORS) },
  get frames() { return [new Frame()] }
}

const SAVE_THROTTLE = 500

class Project {
  constructor(props = {}) {
    let _props = { ...defaultProps, ...props }

    for (let name of Object.getOwnPropertyNames(_props)) {
      this[name] = _props[name]
    }

    // Bind all instance methods with this... :S
    for (let obj = this; obj; obj = Object.getPrototypeOf(obj)){
      for (let name of Object.getOwnPropertyNames(obj)){
        if (typeof this[name] === 'function'){
          this[name] = this[name].bind(this);
        }
      }
    }

    const SAVE_THROTTLE = 500

    this.save = throttle(this.save, SAVE_THROTTLE, { leading: true, trailing: true })

    // Function to update self in svelte store
    this.set = () => {}
  }

  update() {
    return this.set(this)
  }

  /* Colors */

  addColor(color) {
    let index = this.colors.indexOf(color)

    if (index == -1) {
      this.colors = [...this.colors, color]
    }

    this.color = color

    this.update()
  }

  /* End colors */



  /* Frame actions */

  get currentFrame() {
    return this.frames[this.frameIndex]
  }

  get previousFrame() {
    return this.frameIndex > 0 ? this.frames[this.frameIndex - 1] : null
  }

  setFrameRate(value) {
    this.frameRate = Math.min(Math.max(MIN_FRAME_RATE, value), MAX_FRAME_RATE)

    this.update()
  }

  sortFrames(oldIndex, newIndex) {
    let frame = this.frames.splice(oldIndex, 1)[0]

    this.frames.splice(newIndex, 0, frame)

    this.frameIndex = newIndex

    this.update()
  }

  addFrame(event, duplicate = false) {
    const { frames, frameIndex } = this

    let id = this.frameId++

    let newFrame = duplicate ? Frame.clone(frames[frameIndex], id) : new Frame({ id })

    this.frames = [
      ...frames.slice(0, frameIndex + 1),
      newFrame,
      ...frames.slice(frameIndex + 1),
    ]

    this.frameIndex++

    return this.update()
  }

  duplicateFrame() {
    return this.addFrame(null, true)
  }

  clearFrame() {
    this.currentFrame.clear()

    return this.update()
  }

  deleteFrame() {
    if (this.frames.length <= 1) return false

    this.frames.splice(this.frameIndex, 1)

    this.frameIndex = Math.min(this.frameIndex, this.frames.length - 1)

    return this.update()
  }

  /* End frame actions */



  reset() {
    let confirmText = "Are you sure? This resets EVERYTHING."

    if (confirm(confirmText)) {
      this.frameId = 1
      this.frames = [new Frame()]
      this.frameIndex = 0
    }

    return this.update()
  }



  exportGif() {
    let _frames = []

    this.frames.forEach(frame => {
      _frames.push([frame.image, { delay: 1000 / this.frameRate }])
    })

    return createGif(_frames, this.title, this.width, this.height)
  }



  /* Save and restore */

  save() {
    let frames = this.frames.map(frame => frame.serialize(this.colors))

    return localStorage.setItem('latest', JSON.stringify({ ...this, frames }))
  }

  static restore(key) {
    const _object = JSON.parse(localStorage.getItem(key)) || {}

    if (_object.frames) {
      _object.frames = _object.frames.map(_frame => Frame.deserialize(_frame, _object.colors))
    }

    return new Project(_object)
  }

  /* End save and restore */
}

export default Project;