import Frame from './Frame'
import tools from 'tools'

import throttle from 'lodash.throttle'
import { createGif, createSvg, createCanvasImageAsync } from 'lib'

import {
  RESOLUTION,
  PIXEL_SIZE,
  DEFAULT_COLORS,
  MIN_FRAME_RATE,
  MAX_FRAME_RATE,
  DEFAULT_FRAME_RATE
} from 'config/constants'

const SIZE = RESOLUTION * PIXEL_SIZE

const defaultProps = {
  id: 1,
  title: 'Project 1',
  frameId: 1,
  color: DEFAULT_COLORS.black,
  frameIndex: 0,
  frameRate: DEFAULT_FRAME_RATE,
  showUnderlay: true,
  width: SIZE,
  height: SIZE,
  tool: 'brush',
  backgroundColor: DEFAULT_COLORS.white,
  transparent: false,
  infiniteGif: true,
  get colors() { return Object.values(DEFAULT_COLORS) },
  get frames() { return [new Frame()] },
}

class Project {
  constructor(props = {}) {
    let _props = { ...defaultProps, ...props }

    for (let name of Object.getOwnPropertyNames(_props)) {
      this[name] = _props[name]
    }

    // Bind all instance methods with this... :S
    for (let obj = this; obj; obj = Object.getPrototypeOf(obj)){
      for (let name of Object.getOwnPropertyNames(obj)){
        if (typeof this[name] === 'function'){
          this[name] = this[name].bind(this);
        }
      }
    }

    let tool = tools[this.tool]

    this.tool = tool
    tool.project = this

    // Function to update self in svelte store
    this.set = () => {}
  }

  update() {
    return this.set(this)
  }

  /* Colors */

  addColor(color) {
    let index = this.colors.indexOf(color)

    if (index == -1) {
      this.colors = [...this.colors, color]
    }

    this.color = color

    this.update()
  }

  importColors(colors) {
    let currentSet = new Set(this.colors)

    let newColors = colors.filter(color => !currentSet.has(color))

    this.colors = [...this.colors, ...newColors]

    this.update()
  }

  /* End colors */



  /* Frame actions */

  get currentFrame() {
    return this.frames[this.frameIndex]
  }

  get previousFrame() {
    return this.frameIndex > 0 ? this.frames[this.frameIndex - 1] : null
  }

  setFrameRate(value) {
    this.frameRate = Math.min(Math.max(MIN_FRAME_RATE, value), MAX_FRAME_RATE)

    this.update()
  }

  sortFrames(oldIndex, newIndex) {
    let frame = this.frames.splice(oldIndex, 1)[0]

    this.frames.splice(newIndex, 0, frame)

    this.frameIndex = newIndex

    this.update()
  }

  addFrame(event, duplicate = false) {
    const { frames, frameIndex } = this

    let id = this.frameId++

    let newFrame = duplicate ? Frame.clone(frames[frameIndex], id) : new Frame({ id })

    this.frames = [
      ...frames.slice(0, frameIndex + 1),
      newFrame,
      ...frames.slice(frameIndex + 1),
    ]

    this.frameIndex++

    return this.update()
  }

  duplicateFrame() {
    return this.addFrame(null, true)
  }

  clearFrame() {
    this.currentFrame.clear()

    return this.update()
  }

  deleteFrame() {
    if (this.frames.length <= 1) return false

    this.frames.splice(this.frameIndex, 1)

    this.frameIndex = Math.min(this.frameIndex, this.frames.length - 1)

    return this.update()
  }

  /* End frame actions */



  reset() {
    let confirmText = "Are you sure? This resets EVERYTHING."

    if (confirm(confirmText)) {
      this.frameId = 1
      this.frames = [new Frame()]
      this.frameIndex = 0
      this.colors = [...Object.values(DEFAULT_COLORS)]
    }

    return this.update()
  }

  get exportBackground() {
    return this.transparent ? 'rgba(0,0,0,0)' : this.backgroundColor
  }

  get exportTitle() {
    return this.title.replace(/ /g, '_')
  }

  async exportGif(progressCallback = () => {}) {
    let backgroundColor = this.exportBackground

    const images = await Promise.all(
      [...this.frames].map(frame => {
        return createCanvasImageAsync(ctx => frame.render(ctx, backgroundColor))
      })
    )

    const frameRate = 1000 / this.frameRate

    // Convert colors [ '#FF00FF' ... ] to rgb array [ 255, 0, 255, ... ]
    const globalPalette = this.colors.join('').match(/\w{2}/g, '').map(hex => parseInt(hex, 16))

    return createGif({
      images,
      frameRate,
      globalPalette,
      progressCallback,
      debug: false,
      infinite: this.infiniteGif,
      title: this.exportTitle,
      width: this.width,
      height: this.height
    })
  }

  async exportSvg() {
    return createSvg({
      width: SIZE,
      height: SIZE,
      title: this.exportTitle,
      pixels: this.currentFrame.pixels,
      render: ctx => this.currentFrame.render(ctx, this.exportBackground)
    })
  }



  serialize() {
    let frames = this.frames.map(frame => frame.serialize(this.colors))

    return { ...Object.assign({}, this), tool: this.tool.name, frames }
  }

  static deserialize(json) {
    let project = new Project({ ...json })

    if (json.frames) {
      project.frames = json.frames.map(_frame => Frame.deserialize(_frame, project.colors, project.backgroundColor))
    }

    return project
  }
}

export default Project;