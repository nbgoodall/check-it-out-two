import Frame from './Frame'

import { store } from 'store/store'

import throttle from 'lodash.throttle'
import { createGif, createSvg, createCanvasImageAsync } from 'lib'

import {
  CANVAS_SIZE,
  DEFAULT_COLORS,
  MIN_FRAME_RATE,
  MAX_FRAME_RATE,
  DEFAULT_FRAME_RATE
} from 'config/constants'

const defaultProps = {
  id: 1,
  frameId: 2,
  title: 'Project 1',
  color: DEFAULT_COLORS.black,
  frameRate: DEFAULT_FRAME_RATE,
  showUnderlay: true,
  width: CANVAS_SIZE,
  height: CANVAS_SIZE,
  backgroundColor: DEFAULT_COLORS.white,
  transparent: false,
  infiniteGif: true,
  get colors() { return [] }, //Object.values(DEFAULT_COLORS) },
  get frames() { return { 1: new Frame({ id: 1 }) } },
  get frameIds() { return [1] },
}

class Project {
  constructor(props = {}) {
    let _props = { ...defaultProps, ...props }

    for (let name of Object.getOwnPropertyNames(_props)) {
      this[name] = _props[name]
    }

    // Bind all instance methods with this... :S
    for (let obj = this; obj; obj = Object.getPrototypeOf(obj)){
      for (let name of Object.getOwnPropertyNames(obj)){
        if (typeof this[name] === 'function'){
          this[name] = this[name].bind(this);
        }
      }
    }

    // Function to update self in svelte store
    this.set = () => {}

    if (store.get('activeFrameIds').length === 0) {
      store.update({ activeFrameIds: [this.frameIds[0]] })
    }
  }

  update() {
    this.updateColors()

    return this.set(this)
  }

  /* Colors */

  updateColors() {
    let colors = Object.values(this.frames).reduce((arr, frame) => arr.concat(frame.colors), [])

    colors = Array.from(new Set(colors))

    this.addColors(colors)

    // Remove unused colors
    this.colors = this.colors.filter(color => colors.includes(color))
  }

  addColors(colors) {
    for (let color of colors) {
      let index = this.colors.indexOf(color)

      // Add color
      if (index == -1) {
        this.colors = [...this.colors, color]
      }
    }

    return this.colors
  }

  importColors(colors) {
    let currentSet = new Set(this.colors)

    let newColors = colors.filter(color => !currentSet.has(color))

    this.colors = [...this.colors, ...newColors]

    this.update()
  }

  /* End colors */



  /* Frame actions */

  get currentFrame() {
    const [frameId] = store.get('activeFrameIds')

    return this.frames[frameId || this.frameIds[0]]
  }

  get previousFrame() {
    const index = this.frameIds.indexOf(store.get('activeFrameIds')[0])

    return index > 0 ? this.frames[this.frameIds[index - 1]] : null
  }

  get nextFrame() {
    const index = this.frameIds.indexOf(store.get('activeFrameIds')[0])

    return index < this.frameIds.length ? this.frames[this.frameIds[index + 1]] : null
  }

  setFrameRate(value) {
    this.frameRate = Math.min(Math.max(MIN_FRAME_RATE, value), MAX_FRAME_RATE)

    this.update()
  }

  sortFrames(oldIndex, newIndex) {
    const frameId = this.frameIds.splice(oldIndex, 1)[0]

    this.frameIds.splice(newIndex, 0, frameId)

    store.update({ activeFrameIds: [frameId] })

    this.update()
  }

  addFrame(addBefore = false, duplicate = false) {
    const { frames, frameIds } = this

    const index = this.frameIds.indexOf(store.get('activeFrameIds')[0])

    let id = this.frameId++

    let newFrame = duplicate ? Frame.duplicate(frames[this.frameIds[index]], id) : new Frame({ id })

    let position = addBefore ? 0 : 1

    this.frameIds = [
      ...frameIds.slice(0, index + position),
      newFrame.id,
      ...frameIds.slice(index + position),
    ]

    this.frames[newFrame.id] = newFrame

    store.update({ activeFrameIds: [newFrame.id] })

    return this.update()
  }

  duplicateFrame(addBefore) {
    return this.addFrame(addBefore, true)
  }

  clearFrame() {
    this.currentFrame.clear()

    return this.update()
  }

  deleteCurrentFrame() {
    if (this.frameIds.length <= 1) return false

    const index = this.frameIds.indexOf(store.get('activeFrameIds')[0])

    this.frameIds.splice(index, 1)

    store.update({ activeFrameIds: [ this.frameIds[Math.min(index, this.frameIds.length - 1)] ] })

    return this.update()
  }

  /* End frame actions */



  reset() {
    let confirmText = "Are you sure? This resets EVERYTHING."

    if (confirm(confirmText)) {
      this.frameId = 1
      this.frames = [new Frame()]
      this.frameIndex = 0
      this.colors = [...Object.values(DEFAULT_COLORS)]
    }

    return this.update()
  }

  get exportBackground() {
    return this.transparent ? 'rgba(0,0,0,0)' : this.backgroundColor
  }

  get exportTitle() {
    return this.title.replace(/ /g, '_')
  }

  async exportGif(progressCallback = () => {}) {
    let backgroundColor = this.exportBackground

    // return false

    let frames = []

    for (let id of this.frameIds) {
      if (frame.repeat < 1) { continue }

      frames.push({
        ...this.frames[id],
        image: await createCanvasImageAsync(ctx => this.frames[id].render({ ctx, backgroundColor }))
      })
    }

    // const frames = await Promise.all(
    //   [...this.frames].map(frame => {
    //     return createCanvasImageAsync(ctx => frame.render(ctx, backgroundColor))
    //   })
    // )

    const frameRate = 1000 / this.frameRate

    const isHex = color => color[0] === '#'

    // Convert colors [ '#FF00FF' ... ] to rgb array [ 255, 0, 255, ... ]
    const globalPalette = this.colors.filter(isHex).join('').match(/\w{2}/g, '').map(hex => parseInt(hex, 16))

    return createGif({
      frames,
      frameRate,
      globalPalette,
      progressCallback,
      debug: false,
      infinite: this.infiniteGif,
      title: this.exportTitle,
      width: this.width,
      height: this.height
    })
  }

  async exportSvg() {
    return createSvg({
      width: SIZE,
      height: SIZE,
      title: this.exportTitle,
      layers: this.currentFrame.layers,
      render: ctx => this.currentFrame.render({ ctx, backgroundColor: this.exportBackground })
    })
  }

  serialize() {
    let frames = {}

    for (let id of this.frameIds) {
      frames[id] = this.frames[id].serialize(this.colors)
    }

    return { ...Object.assign({}, this), frames }
  }

  static deserialize(json) {
    let project = new Project({ ...json })

    if (json.frames) {
      let frames = {}

      if (Array.isArray(json.frames)) {
        for (let frame of json.frames) {
          frames[frame.id] = Frame.deserialize(frame, project.colors, project.backgroundColor)
        }
      }
      else {
        for (let id in json.frames) {
          frames[id] = Frame.deserialize(json.frames[id], project.colors, project.backgroundColor)
        }
      }

      project.frames = frames
    }

    return project
  }
}

export default Project;