import { RESOLUTION } from 'config/constants'

import Layer from './Layer'

import { createBlankImage, render, createImage, importImage } from 'lib/frames'

const defaultProps = {
  id: 0,
  backgroundColor: 'transparent',
  layerIndex: 0,
  layerId: 1,
  // Prevent those stale defaults
  get image() { return createBlankImage() },
  get pixels() { return new Array(RESOLUTION).fill(new Array(RESOLUTION).fill('transparent')) },
  get layers() { return [new Layer(0)] }
}

class Frame {
  constructor(props = {}) {
    let _props = { ...defaultProps, ...props }

    for (let name of Object.getOwnPropertyNames(_props)) {
      this[name] = _props[name]
    }
  }

  static duplicate(frame, id) {
    let image = frame.image.cloneNode(true),
       pixels = JSON.parse(JSON.stringify(frame.pixels))

    let layers = frame.layers.map(Layer.duplicate)

    const _clone = Object.setPrototypeOf({ ...frame, pixels, image, id, layers }, Frame.prototype)

    return _clone;
  }

  /* Layer actions */

  get currentLayer() {
    return this.layers[this.layerIndex]
  }

  addLayer() {
    let id = this.layerId++

    let newLayer = new Layer({ id })

    this.layers = [ newLayer, ...this.layers ]

    this.layerIndex = 0
  }

  sortLayers(oldIndex, newIndex) {
    let layer = this.layers.splice(oldIndex, 1)[0]

    this.layers.splice(newIndex, 0, layer)

    this.layerIndex = newIndex
  }

  /* End layer actions */

  updatePixel(...args) {
    return this.currentLayer.setPixel(...args)
  }

  clear() {
    for (let layer of this.layers) {
      layer.clear()
    }

    this.saveImage()
  }

  render(ctx, backgroundColor = null) {
    return render(ctx, this.layers, backgroundColor)
  }

  saveImage(backgroundColor) {
    this.image.src = createImage(this.layers, backgroundColor)
  }

  async importImage(src) {
    this.currentLayer.pixels = await importImage(src)

    this.saveImage()
  }

  serialize(colors) {
    const layers = this.layers.map(layer => layer.serialize(colors))

    return { ...Object.assign({}, this), layers }
  }

  static deserialize(json, colors) {
    let frame = new Frame({ ...json })

    const pixels = json.pixels.map(row => row.map(pixelIndex => colors[pixelIndex] || null))

    if (json.layers) {
      frame.layers = json.layers.map(_layer => Layer.deserialize(_layer, colors))
    }

    frame.image = createBlankImage()
    frame.saveImage()

    return frame
  }
}

export default Frame;