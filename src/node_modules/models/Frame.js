import { RESOLUTION, PIXEL_SIZE } from 'config/constants'

const SIZE = PIXEL_SIZE * RESOLUTION

import { store } from 'store/store'

import Layer from './Layer'

import { createBlankImage, render, createImage, importImage } from 'lib/frames'

const defaultProps = {
  id: 0,
  backgroundColor: 'transparent',
  layerId: 1,
  repeat: 1,
  // Prevent those stale defaults
  get image() { return createBlankImage() },
  get layers() { return {} },
  get layerIds() { return [] }
}

class Frame {
  constructor(props = {}) {
    let _props = { ...defaultProps, ...props }

    for (let name of Object.getOwnPropertyNames(_props)) {
      this[name] = _props[name]
    }
  }

  static duplicate(frame, id) {
    let image = frame.image.cloneNode(true)

    let layers = {}

    for (let id of frame.layerIds) {
      layers[id] = Layer.duplicate(frame.layers[id])
    }

    const _clone = Object.setPrototypeOf({ ...frame, image, id, layers }, Frame.prototype)

    return _clone;
  }

  /* Layer actions */

  addLayer() {
    let id = this.layerId++

    let newLayer = new Layer({ id })

    this.layers[newLayer.id] = newLayer

    this.layerIds = [ newLayer.id, ...this.layerIds ]

    store.update(state => ({
      activeLayerIds: [...state.activeLayerIds, newLayer.id]
    }))

    return newLayer
  }

  destroyLayers(ids) {
    for (let id of ids) {
      delete this.layers[id]
    }

    this.layerIds = this.layerIds.filter(id => ids.indexOf(id) === -1)

    this.layerId = Math.max(...this.layerIds, 0) + 1
  }

  sortLayerIds(oldIndex, newIndex) {
    let id = this.layerIds.splice(oldIndex, 1)[0]

    this.layerIds.splice(newIndex, 0, id)
  }

  getPixel(x, y) {
    let layerIds = store.get('activeLayerIds')

    if (layerIds.length !== 1) return null

    return this.layers[layerIds[0]].getPixel(x, y)
  }

  setPixel(x, y, value) {
    let layerIds = store.get('activeLayerIds')

    // User has selected many layers â€” don't want to draw on all at once.. or do we?!
    if (layerIds.length > 1) return false

    let id = layerIds[0]

    let layer = id ? this.layers[id] : this.addLayer()

    return layer.setPixel(x, y, value)
  }

  changeZIndices(layerIds, direction) {
    let ids = [...layerIds].sort((a, b) => this.layerIds.indexOf(a) + direction * this.layerIds.indexOf(b))

    // Cap the bounds
    let atEdge = ids.some(id =>
      (direction === -1 && id === this.layerIds[0]) ||
      (direction === +1 && id === this.layerIds[this.layerIds.length - 1])
    )

    if (atEdge) return false

    for (let id of ids) {
      let index = this.layerIds.indexOf(id)

      let newPositions = this.layerIds.splice(index, 1)

      this.layerIds.splice(Math.max(0, index + direction), 0, ...newPositions)
    }
  }

  /* End layer actions */

  clear() {
    this.layers = {}
    this.layerIds = []
    this.layerId = 1

    store.update({ activeLayerIds: [] })

    this.saveImage()
  }

  render(ctx, backgroundColor = null, pointing = false) {
    ctx.clearRect(0, 0, SIZE, SIZE)

    if (backgroundColor) {
      ctx.fillStyle = backgroundColor
      ctx.fillRect(0, 0, SIZE, SIZE)
    }

    let hoveringId = store.get('hoveringId'),
        activeIds = store.get('activeLayerIds')

    for (let id of [...this.layerIds].reverse()) {
      let alpha = 1

      if (hoveringId) {
        alpha = hoveringId === id ? 1 : 0.8
      } else {
        // HMMM, think of the UX here...
        // alpha = activeIds.includes(id) ? 1 : 0.7
      }

      this.layers[id].render(ctx, {
        alpha,
        hovering: pointing && id === hoveringId,
        active: pointing && activeIds.includes(id)
      })
    }
  }

  saveImage(backgroundColor) {
    this.image.src = createImage(Object.values(this.layers), backgroundColor)
  }

  async importImage(src) {
    this.currentLayer.pixels = await importImage(src)

    this.saveImage()
  }

  serialize(colors) {
    let layers = {}

    for (let id of this.layerIds) {
      layers[id] = this.layers[id].serialize(colors)
    }

    return { ...Object.assign({}, this), layers }
  }

  static deserialize(json, colors) {
    let frame = new Frame({ ...json })

    if (json.layers) {
      let layers = {}

      if (Array.isArray(json.layers)) {
        for (let layer of json.layers) {
          layers[layer.id] = Layer.deserialize(layer, colors)
        }
      }
      else {
        for (let id in json.layers) {
          layers[id] = Layer.deserialize(json.layers[id], colors)
        }
      }

      frame.layers = layers
    }

    frame.image = createBlankImage()
    frame.saveImage()

    return frame
  }
}

export default Frame;