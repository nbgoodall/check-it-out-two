import {
  RESOLUTION,
  PIXEL_SIZE,
  DEFAULT_COLORS
} from 'config/constants'

import { createCanvasImage } from 'lib/createCanvasImageAsync'

const SIZE = PIXEL_SIZE * RESOLUTION

function createBlankImage(color = DEFAULT_COLORS.white) {
  return createCanvasImage(ctx => {
    ctx.fillStyle = color
    ctx.fillRect(0, 0, SIZE, SIZE)
  })
}

const defaultProps = {
  id: 0,
  backgroundColor: 'transparent',
  // Prevent those stale defaults
  get image() { return createBlankImage() },
  get pixels() { return new Array(RESOLUTION).fill(new Array(RESOLUTION).fill('transparent')) }
}

class Frame {
  constructor(props = {}) {
    let _props = { ...defaultProps, ...props }

    for (let name of Object.getOwnPropertyNames(_props)) {
      this[name] = _props[name]
    }
  }

  static clone(frame, id) {
    let image = frame.image.cloneNode(true)

    let pixels = []

    for (let row of frame.pixels) {
      pixels.push([ ...row ])
    }

    const _clone = Object.setPrototypeOf({ ...frame, pixels, image, id }, Frame.prototype)

    return _clone;
  }

  updatePixel(y, x, value) {
    const row = [
      ...this.pixels[y].slice(0, x),
      value,
      ...this.pixels[y].slice(x + 1)
    ]

    this.pixels.splice(y, 1, row)
  }

  clear() {
    this.pixels = defaultProps.pixels

    this.saveImage()
  }

  render(ctx, backgroundColor = null) {
    ctx.clearRect(0, 0, SIZE, SIZE)

    if (backgroundColor) {
      ctx.fillStyle = backgroundColor
      ctx.fillRect(0, 0, SIZE, SIZE)
    }

    for (let [y, row] of this.pixels.entries()) {
      for (let [x, color] of row.entries()) {
        if (!y) { continue }
        ctx.fillStyle = color

        ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
      }
    }
  }

  saveImage(backgroundColor) {
    let _canvas = document.createElement('canvas')

    _canvas.width  = SIZE
    _canvas.height = SIZE

    let _ctx = _canvas.getContext('2d')

    this.render(_ctx, backgroundColor)

    this.image.src = _canvas.toDataURL()
  }

  serialize(colors) {
    const pixels = this.pixels.map(row => row.map(pixel => colors.indexOf(pixel)))

    return { ...this, pixels }
  }

  static deserialize(obj, colors) {
    let frame = new Frame({ ...obj })

    const pixels = obj.pixels.map(row => row.map(pixelIndex => colors[pixelIndex] || 'rgba(0,0,0,0)'))

    frame.pixels = pixels
    frame.image = createBlankImage()
    frame.saveImage()

    return frame
  }
}

export default Frame;