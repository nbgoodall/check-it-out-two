import { RESOLUTION, PIXEL_SIZE } from 'config/constants'

const SIZE = PIXEL_SIZE * RESOLUTION

import { store } from 'store/store'
import { history } from 'store/history'

// import tools from 'tools'

import Layer from './Layer'
import TextLayer from './TextLayer'

import { createBlankImage, render, createImage, importImage } from 'lib/frames'

const defaultProps = {
  id: 0,
  backgroundColor: 'transparent',
  layerId: 1,
  repeat: 1,
  // Prevent those stale defaults
  get image() { return createBlankImage() },
  get layers() { return {} },
  get layerIds() { return [] }
}

const layerKlasses = {
  Layer,
  TextLayer
}

class Frame {
  constructor(props = {}) {
    let _props = { ...defaultProps, ...props }

    for (let name of Object.getOwnPropertyNames(_props)) {
      this[name] = _props[name]
    }
  }

  static duplicate(frame, id) {
    let image = frame.image.cloneNode(true)

    let layers = {}

    for (let id of frame.layerIds) {
      layers[id] = Layer.duplicate(frame.layers[id])
    }

    const _clone = Object.setPrototypeOf({ ...frame, image, id, layers }, Frame.prototype)

    return _clone;
  }

  /* Layer actions */

  resetLayerId() {
    this.layerId = Math.max(...this.layerIds, 0) + 1
  }

  addLayers({ layers }) {
    let layerIds = []

    for (let layer of layers) {
      const Klass = layerKlasses[layer.klass || 'Layer']

      const newLayer = new Klass({ ...layer, id: layer.id || this.layerId++ })

      this.layers[newLayer.id] = newLayer

      layerIds.push(newLayer.id)
    }

    this.layerIds = [ ...layerIds, ...this.layerIds ]

    // this.resetLayerId()
    // this.saveImage()

    return layerIds.map(id => this.layers[id])
  }

  deleteLayers({ layerIds }) {
    for (let id of layerIds) {
      delete this.layers[id]
    }

    this.layerIds = this.layerIds.filter(id => !layerIds.includes(id))

    this.resetLayerId()
    this.saveImage()
  }

  sortLayerIds(oldIndex, newIndex) {
    let id = this.layerIds.splice(oldIndex, 1)[0]

    this.layerIds.splice(newIndex, 0, id)
  }

  getPixel(x, y) {
    let [layerId, ...ids] = store.get('activeLayerIds')

    // Person has selected many layers
    if (!layerId || ids.length > 0) return null

    return this.layers[layerId].getPixel(x, y)
  }

  get colors() {
    let _colors = Object.values(this.layers).reduce((arr, layer) => arr.concat(layer.colors), [])

    return Array.from(new Set(_colors))
  }

  /* End layer actions */

  clear() {
    this.layers = {}
    this.layerIds = []
    this.layerId = 1

    store.update({ activeLayerIds: [] })

    this.saveImage()
  }

  render({ ctx, backgroundColor = null, pointing = false, tool }) {
    ctx.clearRect(0, 0, SIZE, SIZE)

    if (backgroundColor) {
      ctx.fillStyle = backgroundColor
      ctx.fillRect(0, 0, SIZE, SIZE)
    }

    let hoveringIds = store.get('hoveringIds'),
        activeIds = store.get('activeLayerIds')

    for (let id of [...this.layerIds].reverse()) {
      let alpha = 1

      // Full opacity the currently active or hovered layers
      if (hoveringIds.length > 0) {
        alpha = [...hoveringIds, ...activeIds].includes(id) ? 1 : 0.8
      }
      // If a drawing tool is active, lower the opacity of the inactive layers
      else if (!pointing) {
        alpha = activeIds.includes(id) ? 1 : 0.5
      }

      this.layers[id].render(ctx, {
        alpha,
        hovering: pointing && hoveringIds.includes(id),
        active: pointing && activeIds.includes(id)
      })

      if (tool && activeIds.includes(id)) {
        tool.render(ctx)
      }
    }

    if (activeIds.length === 0) {
      tool.render(ctx)
    }
  }

  saveImage(backgroundColor) {
    this.image.src = createImage(Object.values(this.layers), backgroundColor)
  }

  async importImage(src) {
    this.currentLayer.pixels = await importImage(src)

    this.saveImage()
  }

  serialize(colors) {
    let layers = {}

    for (let id of this.layerIds) {
      layers[id] = this.layers[id].serialize(colors)
    }

    return { ...Object.assign({}, this), layers }
  }

  static deserialize(json, colors) {
    let frame = new Frame({ ...json })

    if (json.layers) {
      let layers = {}

      if (Array.isArray(json.layers)) {
        for (let layer of json.layers) {
          layers[layer.id] = Layer.deserialize(layer, colors)
        }
      }
      else {
        for (let id in json.layers) {
          const Klass = layerKlasses[json.layers[id].klass || 'Layer']

          layers[id] = Klass.deserialize(json.layers[id], colors)
        }
      }

      frame.layers = layers
    }

    frame.image = createBlankImage()
    frame.saveImage()

    return frame
  }
}

export default Frame;