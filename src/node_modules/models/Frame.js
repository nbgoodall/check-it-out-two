import { RESOLUTION, PIXEL_SIZE } from 'config/constants'

const SIZE = PIXEL_SIZE * RESOLUTION

import { store } from 'store'

import Layer from './Layer'

import { createBlankImage, render, createImage, importImage } from 'lib/frames'

const defaultProps = {
  id: 0,
  backgroundColor: 'transparent',
  layerId: 1,
  // activeLayerIds: [],
  // Prevent those stale defaults
  get image() { return createBlankImage() },
  get layers() { return {} },
  get layerIds() { return [] }
  // get activeLayerIds() { return [] }
}

class Frame {
  constructor(props = {}) {
    let _props = { ...defaultProps, ...props }

    for (let name of Object.getOwnPropertyNames(_props)) {
      this[name] = _props[name]
    }
  }

  static duplicate(frame, id) {
    let image = frame.image.cloneNode(true),
       pixels = JSON.parse(JSON.stringify(frame.pixels))

    let layers = frame.layers.map(Layer.duplicate)

    const _clone = Object.setPrototypeOf({ ...frame, pixels, image, id, layers }, Frame.prototype)

    return _clone;
  }

  /* Layer actions */

  addLayer() {
    let id = this.layerId++

    let newLayer = new Layer({ id })

    this.layers[newLayer.id] = newLayer

    this.layerIds = [ newLayer.id, ...this.layerIds ]

    store.update(state => ({
      activeLayerIds: [...state.activeLayerIds, newLayer.id]
    }))

    return newLayer
  }

  destroyLayers(ids) {
    for (let id of ids) {
      delete this.layers[id]
    }

    this.layerIds = this.layerIds.filter(id => ids.indexOf(id) === -1)

    this.layerId = Math.max(...this.layerIds, 0) + 1
  }

  sortLayerIds(oldIndex, newIndex) {
    let id = this.layerIds.splice(oldIndex, 1)[0]

    this.layerIds.splice(newIndex, 0, id)
  }

  setPixel(x, y, value) {
    let layerIds = store.get('activeLayerIds')

    // User has selected many layers — don't want to draw on all at once.. or do we?!
    if (layerIds.length > 1) return false

    let id = layerIds[0]

    let layer = id ? this.layers[id] : this.addLayer()

    return layer.setPixel(x, y, value)
  }

  getPixel(x, y) {
    let layerIds = store.get('activeLayerIds')

    if (layerIds.length !== 1) return null

    return this.layers[layerIds[0]].getPixel(x, y)
  }

  /* End layer actions */

  /* Mouse events */

  mouseMove(evt) {
    // TODO: throttle

    // Mouse down
    if (evt.buttons) {
      let layerIds = store.get('activeLayerIds')

      for (let id of layerIds) {
        this.layers[id]._x += evt.movementX
        this.layers[id]._y += evt.movementY
      }
    }
    else {
      store.update({ hoveringId: null })

      let highlighted = false

      let x = Math.floor(evt.offsetX / PIXEL_SIZE),
          y = Math.floor(evt.offsetY / PIXEL_SIZE)

      for (let id of this.layerIds) {
        let layer = this.layers[id]
        layer.hovering = false

        if (!highlighted && layer.getPixel(x, y)) {
          highlighted = true
          layer.hovering = true

          store.update({ hoveringId: layer.id })
        }
      }
    }
  }

  mouseLeave(evt) {
    store.update({ hoveringId: null })
  }

  mouseDown(evt) {
    let activeLayerIds = store.get('activeLayerIds')

    let layer = Object.values(this.layers).find(layer => {
      // Hovering over a layer or clicking within its bounds

      return layer.hovering || (activeLayerIds.includes(layer.id) && layer.withinBounds(evt))
    })

    if (layer) {
      layer.active = true

      if (evt.metaKey || evt.ctrlKey) {

        // Metalicking already active layer? – remove from active
        if (activeLayerIds.includes(layer.id)) {
          let idIndex = activeLayerIds.indexOf(layer.id)

          activeLayerIds.splice(idIndex, 1)
        }
        else {
          activeLayerIds.push(layer.id)
        }
      }
      // Clicking without metakey on a different layer
      else if (!activeLayerIds.includes(layer.id)) {
        activeLayerIds = [layer.id]
      }
    }
    else {
      activeLayerIds = []
    }

    store.update({ activeLayerIds })
  }

  mouseUp(evt) {
    for (let id of this.layerIds) {
      this.layers[id].updateBounds()
      this.layers[id].resetCoords()
    }
  }

  /* End mouse events */

  clear() {
    this.layers = {}
    this.layerIds = []
    this.layerId = 1

    store.update({ activeLayerIds: [] })

    this.saveImage()
  }

  render(ctx, backgroundColor = null, pointer = false) {
    ctx.clearRect(0, 0, SIZE, SIZE)

    if (backgroundColor) {
      ctx.fillStyle = backgroundColor
      ctx.fillRect(0, 0, SIZE, SIZE)
    }

    let hoveringId = store.get('hoveringId'),
        activeIds = store.get('activeLayerIds')

    for (let id of [...this.layerIds].reverse()) {
      let alpha = 1

      if (hoveringId) {
        alpha = hoveringId === id ? 1 : 0.8
      } else {
        // HMMM, think of the UX here...
        // alpha = activeIds.includes(id) ? 1 : 0.7
      }

      this.layers[id].render(ctx, {
        alpha,
        hovering: pointer && id === hoveringId,
        active: pointer && activeIds.includes(id)
      })
    }
  }

  saveImage(backgroundColor) {
    this.image.src = createImage(Object.values(this.layers), backgroundColor)
  }

  async importImage(src) {
    this.currentLayer.pixels = await importImage(src)

    this.saveImage()
  }

  serialize(colors) {
    let layers = {}

    for (let id of this.layerIds) {
      layers[id] = this.layers[id].serialize(colors)
    }

    return { ...Object.assign({}, this), layers }
  }

  static deserialize(json, colors) {
    let frame = new Frame({ ...json })

    if (json.layers) {
      let layers = {}

      for (let id in json.layers) {
        layers[id] = Layer.deserialize(json.layers[id], colors)
      }

      frame.layers = layers
    }

    frame.image = createBlankImage()
    frame.saveImage()

    return frame
  }
}

export default Frame;