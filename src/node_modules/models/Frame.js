import {
  RESOLUTION,
  PIXEL_SIZE,
  DEFAULT_COLORS
} from 'config/constants'

const SIZE = PIXEL_SIZE * RESOLUTION

function createBlankImage(color = DEFAULT_COLORS.white) {
  let canvas = document.createElement('canvas')

  canvas.width  = SIZE
  canvas.height = SIZE

  let ctx = canvas.getContext('2d')

  ctx.fillStyle = color
  ctx.fillRect(0, 0, SIZE, SIZE)

  let image = new Image()

  image.src = canvas.toDataURL()

  return image
}

const defaultProps = {
  id: 0,
  backgroundColor: DEFAULT_COLORS.white,
  // Prevent those stale defaults
  get image() { return createBlankImage() },
  get pixels() { return new Array(RESOLUTION).fill(new Array(RESOLUTION).fill('transparent')) }
}

class Frame {
  constructor(props = {}) {
    let _props = { ...defaultProps, ...props }

    for (let name of Object.getOwnPropertyNames(_props)) {
      this[name] = _props[name]
    }
  }

  static clone(frame, id) {
    let image = frame.image.cloneNode(true)

    const _clone = Object.setPrototypeOf({ ...frame, image, id }, Frame.prototype)

    return _clone;
  }

  updatePixel(y, x, value) {
    const row = [
      ...this.pixels[y].slice(0, x),
      value,
      ...this.pixels[y].slice(x + 1)
    ]

    this.pixels.splice(y, 1, row)
  }

  clear() {
    this.pixels = defaultProps.pixels

    this.saveImage()
  }

  render(ctx, background = true) {
    ctx.clearRect(0, 0, SIZE, SIZE)

    if (background) {
      ctx.fillStyle = this.backgroundColor
      ctx.fillRect(0, 0, SIZE, SIZE)
    }

    for (let [y, row] of this.pixels.entries()) {
      for (let [x, color] of row.entries()) {
        ctx.fillStyle = color

        ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
      }
    }
  }

  saveImage() {
    let _canvas = document.createElement('canvas')

    _canvas.width  = SIZE
    _canvas.height = SIZE

    let _ctx = _canvas.getContext('2d')

    this.render(_ctx)

    this.image.src = _canvas.toDataURL()
  }

  serialize(colors) {
    const pixels = this.pixels.map(row => row.map(pixel => colors.indexOf(pixel)))

    return { ...this, pixels }
  }

  static deserialize(obj, colors) {
    let frame = new Frame({ ...obj })

    const pixels = obj.pixels.map(row => row.map(pixelIndex => colors[pixelIndex] || 'transparent'))

    frame.pixels = pixels
    frame.image = createBlankImage(frame.backgroundColor)
    frame.saveImage()

    return frame
  }
}

export default Frame;