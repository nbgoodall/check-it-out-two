import { RESOLUTION, PIXEL_SIZE } from 'config/constants'

import { createBlankImage, render, createImage, importImage } from 'lib/frames'

import { minMax } from 'lib/arrays'

const HOVER_PADDING = PIXEL_SIZE / 2,
       STROKE_WIDTH = 2

const HEIGHT = 8 * PIXEL_SIZE,
     PADDING = PIXEL_SIZE / 2

import Layer from './Layer'

import Character from 'text/Character'

const SPACE = 1

const canvasPixelPosition = value => {
  return Math.round(value / PIXEL_SIZE) * PIXEL_SIZE
}

class TextLayer extends Layer {
  constructor(props) {
    super(props)

    this.chars = []

    this.klass = 'TextLayer'
  }

  // Breaks otherwise BOOO
  set pixels(val) { return {} }

  get pixels() {
    let pixels = {}

    let width = 0

    for (let char of this.chars || []) {
      for (let x in char.pixels) {
        pixels[width + Number(x)] = char.pixels[x]
      }

      width += char.width + SPACE
    }

    return pixels
  }

  getPixel(x, y) {
    let xOffset = this.x / PIXEL_SIZE,
        yOffset = this.y / PIXEL_SIZE

    return (this.pixels[x - xOffset] || []).includes(y - yOffset)
  }

  updateBounds() {
    const [x1, x2] = minMax(Object.keys(this.pixels).map(Number))

    let yValues = Object.values(this.pixels).reduce((coords, pixels) => coords.concat(Object.keys(pixels)), [])

    const [y1, y2] = minMax(yValues.map(Number))

    this.bounds = [
      x1 * PIXEL_SIZE,
      y1 * PIXEL_SIZE,
      (x2 + 1) * PIXEL_SIZE,
      (y2 + 1) * PIXEL_SIZE
    ]
  }

  getOrigin() {
    const x1 = Math.round((this._x + PADDING / 2) / PIXEL_SIZE),
          y1 = Math.round((this._y - HEIGHT  / 2) / PIXEL_SIZE)

    return { x1, y1 }
  }

  render(ctx, options = {}) {
    const { hovering, active, alpha } = options

    ctx.translate(this.x, this.y)
    ctx.globalAlpha = alpha

    // Underline if hovering
    if (hovering && !active) {
      ctx.lineWidth = 2
      ctx.strokeStyle = '#63B3ED' // tailwind blue 400

      ctx.beginPath()
      ctx.moveTo(-PADDING, 6 * HEIGHT / 8 - PADDING)
      ctx.lineTo(this.width + PADDING, 6 * HEIGHT / 8 - PADDING)
      ctx.stroke()
    }

    ctx.fillStyle = 'red'

    let width = 0

    for (let char of this.chars || []) {
      for (let x in char.pixels) {

        // Char are *arrays* instead of objects like layer pixels
        for (let y of char.pixels[x]) {
          ctx.fillRect(
            (width + Number(x)) * PIXEL_SIZE,
            Number(y) * PIXEL_SIZE,
            PIXEL_SIZE,
            PIXEL_SIZE
          )
        }
      }

      width += char.width + SPACE
    }

    ctx.globalAlpha = 1

    // Active outline
    if (active) {
      ctx.lineWidth = 2
      ctx.strokeStyle = '#63B3ED' // tailwind blue 400

      ctx.strokeRect(
        -PADDING,
        -HEIGHT / 4 + PADDING,
        this.width + 2 * PADDING,
        HEIGHT + 2 * PADDING
      )
    }

    ctx.translate(-this.x, -this.y)
  }

  serialize() {
    return { ...Object.assign({}, this) }
  }

  static deserialize(json) {
    let layer = new TextLayer({ ...json })

    let chars = json.chars.map(char => new Character(char))

    layer.chars = chars

    return layer
  }
}

export default TextLayer