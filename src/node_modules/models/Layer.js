import { RESOLUTION, PIXEL_SIZE } from 'config/constants'

import { createBlankImage, render, createImage, importImage } from 'lib/frames'

import { minMax } from 'lib/arrays'

const HOVER_PADDING = 1,
       STROKE_WIDTH = 2

const canvasPixelPosition = value => {
  return Math.round(value / PIXEL_SIZE) * PIXEL_SIZE
}

const defaultProps = {
  id: 0,
  _x: 0,
  _y: 0,
  hovering: false,
  get pixels() { return {} },
  get bounds() { return [0, 0, 0, 0] } // [x1, y1, x2, y2]
}

class Layer {
  constructor(props) {
    let _props = { ...defaultProps, ...props }

    for (let name of Object.getOwnPropertyNames(_props)) {
      this[name] = _props[name]
    }

    this.updateBounds()
  }

  /* Pixels */

  getPixel(_x, _y) {
    let x = _x - this.x / PIXEL_SIZE,
        y = _y - this.y / PIXEL_SIZE

    let arr = this.pixels[x]

    return arr ? arr[y] : null
  }

  setPixel(_x, _y, value) {
    let x = _x - this.x / PIXEL_SIZE,
        y = _y - this.y / PIXEL_SIZE

    if (this.pixels[x]) {

      if (value === null || value === 'transparent') {
        delete this.pixels[x][y]

        if (Object.keys(this.pixels[x]).length <= 0) {
          delete this.pixels[x]
        }
      }
      else {
        this.pixels[x][y] = value
      }

    }
    else if (value && value !== 'transparent') {
      this.pixels[x] = { [y]: value }
    }

    this.pixels
  }

  // For them rapid updates
  mergePixels(pixels) {
  }

  clear() {
    this.pixels = defaultProps.pixels
  }

  resetCoords() {
    /*
      ._x and ._y are exact positions, so moving multiple layers can cause jiggedy wiggedy behaviour.

      This resets them to the pixel grid.
    */

    this._x = Math.round(this._x / PIXEL_SIZE) * PIXEL_SIZE
    this._y = Math.round(this._y / PIXEL_SIZE) * PIXEL_SIZE
  }

  /* End pixels */

  /* Layer bounds */
  updateBounds() {
    const [x1, x2] = minMax(Object.keys(this.pixels).map(Number))

    let yValues = Object.values(this.pixels).reduce((coords, pixels) => coords.concat(Object.keys(pixels)), [])

    const [y1, y2] = minMax(yValues.map(Number))

    this.bounds = [
      x1 * PIXEL_SIZE,
      y1 * PIXEL_SIZE,
      (x2 + 1) * PIXEL_SIZE,
      (y2 + 1) * PIXEL_SIZE
    ]
  }

  withinBounds(evt) {
    const [minX, minY, maxX, maxY] = this.bounds

    return evt.offsetX > (minX + this.x) &&
           evt.offsetY > (minY + this.y) &&
           evt.offsetX < (maxX + this.x) &&
           evt.offsetY < (maxY + this.y)
  }

  /* End layer bounds */


  /* Rendering */

  render(ctx, options = {}) {
    const { alpha, hovering, active } = options

    // console.log(this._x + this.bounds[0])

    ctx.translate(this.x, this.y)
    ctx.globalAlpha = alpha

    // Shape outline if hovering
    if (hovering && !active) {
      ctx.fillStyle = '#63B3ED'

      for (let x in this.pixels) {
        for (let y in this.pixels[x]) {
          ctx.fillRect(
            x * PIXEL_SIZE - STROKE_WIDTH,
            y * PIXEL_SIZE - STROKE_WIDTH,
            PIXEL_SIZE + 2 * STROKE_WIDTH,
            PIXEL_SIZE + 2 * STROKE_WIDTH
          )
        }
      }
    }

    // The layer itself
    for (let x in this.pixels) {
      for (let y in this.pixels[x]) {
        let color = this.pixels[x][y]

        ctx.fillStyle = color

        ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE)
      }
    }

    ctx.globalAlpha = 1
    ctx.translate(-this.x, -this.y)

    // Active outline
    if (active) {
      const [minX, minY, maxX, maxY] = this.bounds

      ctx.lineWidth = 2
      ctx.strokeStyle = '#63B3ED' // tailwind blue 400

      ctx.strokeRect(
        this.x + minX - HOVER_PADDING,
        this.y + minY - HOVER_PADDING,
        maxX - minX + 2 * HOVER_PADDING,
        maxY - minY + 2 * HOVER_PADDING
      )
    }
  }

  /* End rendering */

  get x() {
    return canvasPixelPosition(this._x)
  }

  get y() {
    return canvasPixelPosition(this._y)
  }

  get x1() {
    return this._x + this.bounds[0]
  }

  get y1() {
    return this._y + this.bounds[1]
  }

  get x2() {
    return this._x + this.bounds[2]
  }

  get y2() {
    return this._y + this.bounds[3]
  }

  get width() {
    return this.x2 - this.x1
  }

  get height() {
    return this.y2 - this.y1
  }

  /* Persistence */

  serialize(colors) {
    let pixels = {}

    for (let x in this.pixels) {
      pixels[x] = {}

      for (let y in this.pixels[x]) {
        pixels[x][y] = colors.indexOf(this.pixels[x][y])
      }
    }

    return { ...Object.assign({}, this), pixels }
  }

  static deserialize(json, colors) {
    let layer = new Layer({ ...json })

    let pixels = {}

    if (Array.isArray(json.pixels)) {
      for (let [y, row] in json.pixels.entries()) {
        for (let [x, color] in row.entries()) {
          (pixels[x] = pixels[x] || {})[y] = colors[color]
        }
      }
    }
    else {
      for (let x in json.pixels) {
        pixels[x] = {}

        for (let y in json.pixels[x]) {
          pixels[x][y] = colors[json.pixels[x][y]]
        }
      }
    }

    layer.pixels = pixels

    return layer
  }

  /* End persistence */

  static duplicate(layer) {
    let pixels = {}

    for (let x in layer.pixels) {
      pixels[x] = { ...layer.pixels[x] }
    }

    const _clone = Object.setPrototypeOf({ ...layer, pixels }, Layer.prototype)

    return _clone;
  }
}

export default Layer