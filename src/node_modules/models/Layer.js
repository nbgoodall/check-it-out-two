import { RESOLUTION, PIXEL_SIZE } from 'config/constants'

import { createBlankImage, render, createImage, importImage } from 'lib/frames'

import PixelGrid from './PixelGrid'

const HOVER_PADDING = 0

const defaultProps = {
  id: 0,
  _x: 0,
  _y: 0,
  hovering: false
}

class Layer extends PixelGrid {
  constructor(props) {
    super()

    let _props = { ...defaultProps, ...props }

    for (let name of Object.getOwnPropertyNames(_props)) {
      this[name] = _props[name]
    }
  }

  getPixel(...args) {
    return this.get(...args)
  }

  setPixel(...args) {
    return this.set(...args)
  }

  static duplicate(layer) {
    let pixels = {}

    for (let x in layer.pixels) {
      pixels[x] = { ...layer.pixels[x] }
    }

    const _clone = Object.setPrototypeOf({ ...layer, pixels }, Layer.prototype)

    return _clone;
  }

  clear() {
    this.pixels = defaultProps.pixels
  }

  inBounds(evt) {
    const [minX, minY, maxX, maxY] = this.bounds

    return evt.offsetX > minX &&
           evt.offsetY > minY &&
           evt.offsetX < maxX &&
           evt.offsetY < maxY
  }

  onMouseMove(evt, isTarget) {
    this.hovering = this.inBounds(evt)

    if (isTarget) {
      this._x += evt.movementX
      this._y += evt.movementY
    }
  }

  render(ctx) {
    // if (this.hovering) {
    //   const [minX, minY, maxX, maxY] = this.bounds

    //   ctx.lineWidth = 2
    //   ctx.strokeStyle = '#00F9FF'

    //   ctx.strokeRect(
    //     this.x + minX - HOVER_PADDING,
    //     this.y + minY - HOVER_PADDING,
    //     maxX - minX + 2 * HOVER_PADDING,
    //     maxY - minY + 2 * HOVER_PADDING
    //   )
    // }
  }

  setBounds() {
    let pixels = this.pixels

    function minX() {
      for (let i = 0; i < pixels[0].length; i++) {
        for (let j = 0; j < pixels.length; j++) {
          if (pixels[j][i] !== null) {
            return minX = i * PIXEL_SIZE
          }
        }
      }

      return 0
    }

    function minY() {
      for (let i = 0; i < pixels.length; i++) {
        if (pixels[i].some(val => val !== null)) {
          return minY = i * PIXEL_SIZE
        }
      }

      return 0
    }

    function maxX() {
      for (let i = pixels[0].length - 1; i >= 0; i--) {
        for (let j = 0; j < pixels.length; j++) {
          if (pixels[j][i] !== null) {
            return maxX = (i + 1) * PIXEL_SIZE
          }
        }
      }

      return 0
    }

    function maxY() {
      for (let i = pixels.length - 1; i >= 0; i--) {
        if (pixels[i].some(val => val !== null)) {
          return maxY = (i + 1) * PIXEL_SIZE
        }
      }

      return 0
    }

    this.bounds = [minX(), minY(), maxX(), maxY()]
  }

  pos(val) {
    return Math.round(val / PIXEL_SIZE) * PIXEL_SIZE
  }

  get x() {
    return this.pos(this._x)
  }

  set x(val) {
    this._x = val
  }

  get y() {
    return this.pos(this._y)
  }

  set y(val) {
    this._y = val
  }

  serialize(colors) {
    let pixels = {}

    for (let x in this.pixels) {
      pixels[x] = {}

      for (let y in this.pixels[x]) {
        pixels[x][y] = colors.indexOf(this.pixels[x][y])
      }
    }

    return { ...Object.assign({}, this), pixels }
  }

  static deserialize(json, colors) {
    let layer = new Layer({ ...json })

    let pixels = {}

    for (let x in json.pixels) {
      pixels[x] = {}

      for (let y in json.pixels[x]) {
        pixels[x][y] = colors[json.pixels[x][y]]
      }
    }

    layer.pixels = pixels

    return layer
  }
}

export default Layer