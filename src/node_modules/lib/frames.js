import {
  RESOLUTION,
  PIXEL_SIZE,
  DEFAULT_COLORS
} from 'config/constants'

import { createCanvasImage } from 'lib/createCanvasImageAsync'

const SIZE = PIXEL_SIZE * RESOLUTION

function createBlankImage(color = DEFAULT_COLORS.white) {
  return createCanvasImage(ctx => {
    ctx.fillStyle = color
    ctx.fillRect(0, 0, SIZE, SIZE)
  })
}

function renderLayer(ctx, layer) {
  ctx.translate(layer.x, layer.y)

  // console.log(layer.pixels)

  for (let x in layer.pixels) {
    for (let y in layer.pixels[x]) {
      let color = layer.pixels[x][y]

      if (color && color !== 'transparent') {
        ctx.fillStyle = color

        ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
      }
    }
  }

  // for (let [y, row] of layer.pixels.entries()) {
  //   for (let [x, color] of row.entries()) {
  //     if (color && color !== 'transparent') {
  //       ctx.fillStyle = color

  //       ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
  //     }
  //   }
  // }

  ctx.translate(-layer.x, -layer.y)
}

function render(ctx, layers, backgroundColor = null) {
  ctx.clearRect(0, 0, SIZE, SIZE)

  if (backgroundColor) {
    ctx.fillStyle = backgroundColor
    ctx.fillRect(0, 0, SIZE, SIZE)
  }

  for (let layer of [...layers].reverse()) {
    renderLayer(ctx, layer)
  }
}

function createCanvas() {
  let canvas = document.createElement('canvas')

  canvas.width  = SIZE
  canvas.height = SIZE

  let ctx = canvas.getContext('2d')

  return { canvas, ctx }
}

function createImage(layers, backgroundColor) {
  const { canvas, ctx } = createCanvas()

  render(ctx, layers, backgroundColor)

  return canvas.toDataURL()
}

Array.prototype.mean = function() {
  return this.reduce((sum, val) => sum + val, 0) / this.length
}

function alphaBlend(color, alpha) {
  let val = ((1 - alpha) * 1) + (alpha * color / 255)

  return Math.round(val * 255)
}

function rgbaToHex(r, g, b, alpha) {
  let hex = '#'

  for (let v of [r, g, b]) {
    let color = alphaBlend(v, alpha)

    hex += color.toString(16).padStart(2, '0')
  }

  return hex.toUpperCase()
}

function getPixel(arr, x, y) {
  let [r, g, b, a] = [[], [], [], []]

  let firstIndex =  (y * PIXEL_SIZE * SIZE * 4) + (x * PIXEL_SIZE * 4)

  for (let j = 0; j < PIXEL_SIZE; j++) {
    let posY = firstIndex + (j * SIZE * 4)

    for (let i = 0; i < PIXEL_SIZE; i++) {
      let index = posY + i * 4

      r.push(arr[index])
      g.push(arr[index + 1])
      b.push(arr[index + 2])
      a.push(arr[index + 3])
    }
  }

  let alpha = a.mean() / 255

  if (alpha < 0.1) {
    return null
  }
  else {
    return rgbaToHex(r.mean(), g.mean(), b.mean(), alpha)
  }
}

// pixelArr = "a Uint8ClampedArray representing a one-dimensional array containing the data in the RGBA order, with integer values between 0 and 255 (inclusive)."

function pixelizeImage(pixelArr) {
  let pixels = []

  for (let y = 0; y < RESOLUTION; y++) {
    let row = []

    for (let x = 0; x < RESOLUTION; x++) {
      row.push(getPixel(pixelArr, x, y))
    }

    pixels.push(row)
  }

  return pixels
}

const importImage = async src => new Promise(resolve => {
  const { canvas, ctx } = createCanvas()

  let image = new Image()

  image.onload = function() {
    const { width, height } = image

    let scalingFactor = Math.max(width, height) / SIZE

    ctx.drawImage(image, 0, 0, width / scalingFactor, height / scalingFactor)

    let pixelData = ctx.getImageData(0, 0, SIZE, SIZE).data

    resolve(pixelizeImage(pixelData))
  }

  image.src = src
})

export {
  createBlankImage,
  render,
  createImage,
  importImage
}




