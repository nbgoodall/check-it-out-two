import CS2 from 'canvas2svg'

import {
  RESOLUTION,
  PIXEL_SIZE
} from 'config/constants'

const SIZE = RESOLUTION * PIXEL_SIZE

import createDownload from './createDownload'

const coords = (x, y) => `${ x }_${ y }`

const splitCoords = coords => coords.split('_').map(Number)

function pixelFill(x, y, pixels) {
  let filled = [],
      targetColor = pixels[y][x]

  function _fill(x, y) {
    if (filled.includes(coords(x, y))) return false

    filled.push(coords(x, y))

    if (y < RESOLUTION - 1 && pixels[y + 1][x] == targetColor) {
      _fill(x, y + 1)
    }

    if (y > 0 && pixels[y - 1][x] == targetColor) {
      _fill(x, y - 1)
    }

    if (x < RESOLUTION - 1 && pixels[y][x + 1] == targetColor) {
      _fill(x + 1, y)
    }

    if (x > 0 && pixels[y][x - 1] == targetColor) {
      _fill(x - 1, y)
    }
  }

  _fill(x, y)

  return { filled, color: targetColor }
}

function createGroups({ pixels }) {
  let groups = [],
      filled = []

  for (let y = 0; y < RESOLUTION; y++) {
    for (let x = 0; x < RESOLUTION; x++) {
      if (filled.includes(coords(x, y))) continue

      if ((pixels[y] || {})[x] && pixels[y][x] !== 'transparent') {
        let { filled: group, color } = pixelFill(x, y, pixels)

        groups.push({ group, color })
        filled.push(...group)
      }
    }
  }

  return groups
}

const vertexSort = (first, second) => (vertexA, vertexB) => {
  let n = vertexA[first] - vertexB[first]

  if (n !== 0) return n

  return vertexA[second] - vertexB[second]
}

function getVertices(group) {
  let vertices = new Set([])

  for (let pixel of group.map(splitCoords)) {
    let [x, y] = pixel

    vertices.add(coords(x, y))
    vertices.add(coords(x, y + 1))
    vertices.add(coords(x + 1, y))
    vertices.add(coords(x + 1, y + 1))
  }

  return Array.from(vertices).map(splitCoords)
}

function getHorizontalEdges(group) {
  const includes = (x, y) => group.includes(coords(x, y))

  const vertices = getVertices(group).sort(vertexSort(1, 0))

  let edges = []

  for (let [x, y] of vertices) {
    let bottomleftPixel = includes(x - 1, y),
           topLeftPixel = includes(x - 1, y - 1),
            bottomPixel = includes(x, y),
               topPixel = includes(x, y - 1)

    // Vertex is contained or on a vertical edge with the left side exposed to the fearful elements of Moria
    if (topPixel && bottomPixel && ((topLeftPixel && bottomleftPixel) || (!topLeftPixel && !bottomleftPixel))) {
      continue
    }

    let lastEdge = edges[edges.length - 1]

    // Is the previous edge right behind this one?
    let onCurrentPlane = lastEdge && lastEdge[1][0] === x - 1 && lastEdge[1][1] === y

    // One of the previous top/bottom pixels exists, but not both
    let onePixelExists = (bottomleftPixel || topLeftPixel) && !(bottomleftPixel && topLeftPixel)

    if (onCurrentPlane && onePixelExists ) {
      lastEdge[1] = [x, y]
    }
    // Otherwise start fresh if there's a pixel above or below
    else if (topPixel || bottomPixel) {
      edges.push([[x, y], [x, y]])
    }
  }

  return edges
}

function getVerticalEdges(edges) {
  let vertices = edges.flat().sort(vertexSort(0, 1))

  for (let i = 0; i < vertices.length; i += 2) {
    edges.push([vertices[i], vertices[i + 1]])
  }

  return edges
}

function getEdges(group) {
  const edges = getHorizontalEdges(group)

  return getVerticalEdges(edges)
}

function createPaths({ group, color }) {
  let edges = getEdges(group)

  let paths = []

  function createPath(edges, direction = 0) {
    let pathSet = new Set([...edges[0]])

    while (edges.length > 0) {
      let lastPoint = Array.from(pathSet).pop()

      let index = edges.findIndex(edge => {
        let [start, end] = edge

        let x = direction, y = 1 - direction

        return (lastPoint[0] === start[0] && lastPoint[1] === start[1]) ||
               (lastPoint[0] ===   end[0] && lastPoint[1] ===   end[1])
      })

      // Edges don't connect (hollow polygon)
      if (index == -1) break

      pathSet.add(edges[index][0])
      pathSet.add(edges[index][1])

      edges.splice(index, 1)
    }

    let path = Array.from(pathSet)

    // Add starting point again for complete path
    paths.push([...path, path[0]])

    if (edges.length > 0) {
      return createPath(edges)
    }
  }

  createPath(edges)

  return { paths, color }
}


function createPolygons({ pixels }) {
  const groups = createGroups({ pixels })

  const paths = groups.map(createPaths)

  return paths
}

function render(ctx, polygons) {
  for (let polygon of polygons) {
    ctx.beginPath()

    for (let [index, path] of polygon.paths.entries()) {
      // Anti-clockwise for inner paths #yolo
      if (index === 1) {
        path = path.reverse()
      }

      let [startX, startY] = path[0]

      ctx.moveTo(startX * PIXEL_SIZE,  startY * PIXEL_SIZE)

      for (let point of path.slice(1)) {
        ctx.lineTo(point[0] * PIXEL_SIZE, point[1] * PIXEL_SIZE)
      }

      ctx.closePath()
    }

    ctx.fillStyle = polygon.color
    ctx.fill()
  }

  ctx.fill()
}


function createCanvas() {
  let canvas = document.createElement('canvas')

  canvas.width  = SIZE
  canvas.height = SIZE

  let ctx = canvas.getContext('2d')

  return { canvas, ctx }
}

function createSvg({ width, height, title, layers }) {
  let ctx = new C2S(width, height)

  for (let layer of layers) {
    let polygons = createPolygons({ pixels: layer.pixels })

    render(ctx, polygons)
  }


  let svgData = ctx.getSerializedSvg(true)

  let blob = new Blob([ svgData ], { type: 'image/svg+xml;charset=utf-8' })

  return createDownload(blob, title + '.svg')
}

export default createSvg