import { writable, derived, get } from 'svelte/store'
import Project from 'models/Project'

import { getValue, setValue } from './utils'

const PROJECTS_KEY = '@projects',
      METADATA_KEY = '@projects_metadata',
        LATEST_KEY = '@latest'

const storageKey = id => `${ PROJECTS_KEY }_${ id }`

function updateStoreProject(project) {
  PROJECT.set(project)

  // Assign the update function for within the project instance
  project.set = PROJECT.set

  return project
}

function setCurrentProject(id) {
  let project = projects.read(id)

  return updateStoreProject(project)
}


/* LATEST PROJECT KEY */

const latest = {
  read: function() {
    return parseInt(localStorage[LATEST_KEY])
  },

  update: function(id) {
    return localStorage[LATEST_KEY] = id
  }
}

/* END LATEST PROJECT KEY */


/* PROJECT METADATA */

// { 1: { id: 1, title: 'Title', frames: 35, image: ... }, ... }
const metadata = {
  read: function() {
    return getValue(METADATA_KEY) || {}
  },

  update: function(value) {
    METADATA.set(value)

    return setValue(METADATA_KEY, value)
  },

  insert: function(project) {
    let _metadata = { ...this.read() }

    _metadata[project.id] = {
      id: project.id,
      title: project.title,
      frames_count: project.frameIds.length,
      image: project.frames[project.frameIds[0]].image.src
    }

    return this.update(_metadata)
  },

  delete: function(projectId) {
    let _metadata = { ...this.read() }

    delete _metadata[projectId]

    return this.update(_metadata)
  },

  maxId: function() {
    let ids = Object.keys(this.read()).map(Number)

    return Math.max(...ids)
  },

  count: function() {
    return Object.keys(this.read()).length
  }
}

/* END PROJECT METADATA */


/* PROJECTS */

const projects = {
  create: function() {
    const id = metadata.maxId() + 1

    const project = new Project({ id: id, title: `Project ${ id }` })

    metadata.insert(project)

    return updateStoreProject(project)
  },

  read: function(id) {
    let project = getValue(storageKey(id))

    if (project) {
      project = Project.deserialize(project)

      latest.update(project.id)
    }

    return project
  },

  readAll: function() {
    const PROJECT_KEY_REGEX = /^@projects_\d+$/

    for (let [key, value] of Object.entries(localStorage)) {
      if (key.match(PROJECT_KEY_REGEX)) {
        let project = Project.deserialize(JSON.parse(value))

        metadata.insert(project)
      }
    }
  },

  readLatest: function() {
    let id = latest.read()

    if (!id) {
      let _metadata = metadata.read()

      id = Object.keys(_metadata)[0]
    }

    return this.read(id) || new Project()
  },

  update: function(project) {
    setValue(storageKey(project.id), project.serialize())

    latest.update(project.id)

    return metadata.insert(project)
  },

  delete: function(id) {
    let latestId = latest.read()

    metadata.delete(id)

    localStorage.removeItem(storageKey(id))

    if (latestId === id) {
      let nextId = metadata.maxId()

      setCurrentProject(nextId)

      latest.update(nextId)
    }
  }
}

/* END PROJECTS */


/* Svelte stores */

const METADATA = writable(metadata.read())

async function refreshMetadata() {
  projects.readAll()
}

refreshMetadata()

const PROJECT = writable(projects.readLatest(), set => {
  // Assign the store setter for manual updates within the project instance
  get(PROJECT).set = set
})

PROJECT.subscribe(projects.update)

const FRAME = derived(PROJECT, $project => $project.currentFrame)

const LAYER = derived(FRAME, $frame => $frame.currentLayer)

/* End svelte stores */

const createProject = projects.create
const deleteProject = projects.delete

export {
  PROJECT as project,
  FRAME as frame,
  LAYER as layer,
  METADATA as projects,
  createProject,
  deleteProject,
  setCurrentProject
}