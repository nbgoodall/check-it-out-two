<script>
  import { onMount } from 'svelte'
  import { PIXEL_SIZE, RESOLUTION } from 'config/constants'

  const SIZE = PIXEL_SIZE * RESOLUTION

  const SCALE = window.devicePixelRatio

  import { project } from 'store'

  let canvasEl, ctx,
      isMouseDown = false,
      selectingColor = null

  // When project.frames updates, this block will be called
  $: $project.frames && canvasEl && render()

  onMount(() => {
    ctx = canvasEl.getContext('2d')

    ctx.scale(SCALE, SCALE)
  })

  function render() {
    $project.currentFrame.render(ctx, false)
  }

  const pixelPosition = pos => Math.max(0, Math.floor(pos / PIXEL_SIZE))

  function mouseDown(evt) {
    const rect = canvasEl.getBoundingClientRect()

    const x = pixelPosition(evt.clientX - rect.left),
          y = pixelPosition(evt.clientY - rect.top)

    let newColor = $project.currentFrame.pixels[y][x] === $project.color ? 'transparent' : $project.color

    if (!isMouseDown && !selectingColor) {
      selectingColor = newColor
    }

    $project.currentFrame.updatePixel(y, x, selectingColor || newColor)

    render()
  }

  function saveImage() {
    $project.currentFrame.saveImage()

    $project.update()
  }

</script>

<svelte:body
  on:mousedown={() => isMouseDown = true }
  on:mouseup={ () => { isMouseDown = false; selectingColor = null }}
/>

<div class="relative bg-white" style="width: { SIZE }px; height: { SIZE }px;">
  {#if $project.showUnderlay && $project.frameIndex > 0}
     <img src={ $project.previousFrame.image.src } class="absolute inset-0 opacity-25">
  {/if}

  <canvas
    bind:this={ canvasEl }
    width={  SIZE * SCALE }
    height={ SIZE * SCALE }
    style="width: { SIZE }px; height: { SIZE }px;"
    class="absolute inset-0"
    on:mousedown={ mouseDown }
    on:mouseup={ saveImage }
    on:mouseleave={ evt => evt.buttons === 1 && saveImage() }
    on:mousemove={  evt => evt.buttons === 1 && mouseDown(evt) }
  />
</div>