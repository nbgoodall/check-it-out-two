import Tool from './Tool'

import { get } from 'svelte/store'

import { project, store } from 'store'

import { RESOLUTION, PIXEL_SIZE } from 'config/constants'

import { minMax } from 'lib/arrays'

import { MoveLayers } from 'commands'

class Pointer extends Tool {
  constructor() {
    super()

    this.cursor = 'default'

    this.name = 'pointer'
  }

  findLayer(evt) {
    const frame = get(project).currentFrame

    const { activeLayerIds, hoveringIds } = get(store)

    // Hovering over a layer or clicking within its bounds
    return Object.values(frame.layers).find(layer => {
      return hoveringIds.includes(layer.id) || (activeLayerIds.includes(layer.id) && layer.withinBounds(evt))
    })
  }

  mouseDown(evt) {
    super.mouseDown(evt)

    this.layersMoved = false

    let activeLayerIds = store.get('activeLayerIds')

    let layer = this.findLayer(evt)

    if (layer) {
      this.layer = layer

      if (!activeLayerIds.includes(layer.id)) {
        let metaKey = evt.metaKey || evt.ctrlKey

        activeLayerIds = metaKey ? [...activeLayerIds, layer.id] : [layer.id]

        this.addedLayer = true
      }
    }
    else {
      activeLayerIds = []
    }

    store.update({ activeLayerIds })
  }

  mouseUp(evt) {
    let { activeLayerIds, hoveringIds } = get(store)

    if (this.layer) {
      if (this.layersMoved) {
        // Normalize dem coords
        const [x1, y1, x2, y2] = Object.values(this.getPositions()).map(c => c * PIXEL_SIZE)

        MoveLayers.perform({
          frameId: get(project).currentFrame.id,
          layerIds: [this.layer.id],
          dx: x2 - x1,
          dy: y2 - y1
        })
      }

      let metaKey = evt.metaKey || evt.ctrlKey

      // Clicking on layer without moving mouse and without adding a new layer (from mouse down) â€” remove that layer from selection!
      if (metaKey && !this.addedLayer && !this.layersMoved) {
        let idIndex = activeLayerIds.indexOf(this.layer.id)

        activeLayerIds.splice(idIndex, 1)
      }
    }
    else if (hoveringIds.length > 0) {
      activeLayerIds = hoveringIds
    }

    store.update({ activeLayerIds })

    super.mouseUp(evt)

    this.layer = null
    this.addedLayer = false
  }

  mouseMove(evt) {
    super.mouseMove(evt)

    const frame = get(project).currentFrame

    // Move layer(s)
    if (evt.buttons) {
      const layerIds = store.get('activeLayerIds')

      if (layerIds.length > 0) {
        this.layersMoved = true

        for (let id of layerIds) {
          frame.layers[id]._x += evt.movementX
          frame.layers[id]._y += evt.movementY
        }
      }
    }

    // Hovering over layers
    else {
      this.reset()

      store.update({ hoveringIds: [] })

      let highlighted = false

      let x = Math.floor(evt.offsetX / PIXEL_SIZE),
          y = Math.floor(evt.offsetY / PIXEL_SIZE)

      for (let id of frame.layerIds) {
        let layer = frame.layers[id]

        if (!highlighted && layer.getPixel(x, y)) {
          highlighted = true

          store.update({ hoveringIds: [layer.id] })
        }
      }
    }
  }

  mouseLeave(evt) {
    return store.update({ hoveringIds: [] })
  }

  render(ctx) {
    let activeLayerIds = store.get('activeLayerIds')

    // Not selecting active layers or somethin'
    if (activeLayerIds.length === 0 && Number.isInteger(this.x2)) {
      let frame = get(project).currentFrame

      const [x1, x2] = minMax(this.x1, this.x2),
            [y1, y2] = minMax(this.y1, this.y2)

      // Layer collisions...
      let hoveringIds = []

      for (let id of frame.layerIds) {
        let layer = frame.layers[id]

        if (x1 < layer.x2 &&
            x2 > layer.x1 &&
            y1 < layer.y2 &&
            y2 > layer.y1)
        {
          hoveringIds.push(layer.id)
        }
      }

      store.update({ hoveringIds })

      // Draw overlay
      ctx.fillStyle = 'rgba(1, 150, 255, 0.2)'
      ctx.fillRect(this.x1, this.y1, this.width, this.height)


      // Draw border
      let gradient = ctx.createLinearGradient(this.x1, this.y1, this.width, this.height)

      gradient.addColorStop(0,   '#B794F4');
      gradient.addColorStop(0.5, '#F687B3');
      gradient.addColorStop(1,   '#7F9CF5');

      ctx.lineWidth = 1
      ctx.strokeStyle = gradient

      ctx.strokeRect(this.x1, this.y1, this.width, this.height)
    }
  }
}

export default new Pointer()