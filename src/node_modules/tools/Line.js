import Tool from './Tool'

import { PIXEL_SIZE } from 'config/constants'

import { getPixelPosition, hexToRgba } from 'lib'

class Line extends Tool {
  constructor() {
    super()

    this.cursor = 'crosshair'

    this.pixels = []

    this.name = 'line'
  }

  mouseDown(evt) {
    this.startX = evt.offsetX
    this.startY = evt.offsetY

    this.x = evt.offsetX
    this.y = evt.offsetY
  }

  reset() {
    this.startX = null
    this.startY = null
    this.x = null
    this.y = null
  }

  mouseMove(evt) {
    const isMouseDown = evt.buttons == 1

    if (!isMouseDown) {
      this.reset()

      return false
    }

    this.x = evt.offsetX
    this.y = evt.offsetY
  }

  getPositions() {
    return {
      x1: getPixelPosition(this.startX),
      y1: getPixelPosition(this.startY),
      x2: getPixelPosition(this.x),
      y2: getPixelPosition(this.y)
    }
  }

  bresenhamLine(callback) {
    const { x1, y1, x2, y2 } = this.getPositions()

    let deltaX = Math.abs(x2 - x1),
        deltaY = Math.abs(y2 - y1)

    let sx = (x1 < x2) ? 1 : -1,
        sy = (y1 < y2) ? 1 : -1

    let error = deltaX - deltaY

    let x = x1, y = y1

    while(true) {
      callback(x, y)

      if ((x === x2) && (y === y2)) break

      let err2 = 2 * error;

      if (err2 > -deltaY) {
        error -= deltaY
        x     += sx
      }

      if (err2 < deltaX) {
        error += deltaX
        y     += sy
      }
    }
  }

  mouseUp(evt) {
    this.bresenhamLine((x, y) => {
      return this.project.currentFrame.setPixel(x, y, this.project.color)
    })

    this.reset()
  }

  render(ctx) {
    if (this.startX && this.startY && this.x && this.y) {
      ctx.fillStyle = hexToRgba(this.project.color, 0.5)

      this.bresenhamLine((x, y) => {
        ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
      })
    }
  }
}

export default new Line()