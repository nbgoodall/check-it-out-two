import Tool from './Tool'

import { PIXEL_SIZE } from 'config/constants'

import { getPixelPosition, hexToRgba } from 'lib'

class Ellipse extends Tool {
  constructor() {
    super()

    this.cursor = 'crosshair'

    this.name = 'ellipse'
  }

  mouseDown(evt) {
    this.startX = evt.offsetX
    this.startY = evt.offsetY

    this.x = evt.offsetX
    this.y = evt.offsetY
  }

  reset() {
    this.startX = null
    this.startY = null
    this.x = null
    this.y = null
  }

  mouseMove(evt) {
    const isMouseDown = evt.buttons == 1

    if (!isMouseDown) {
      this.reset()

      return false
    }

    this.x = evt.offsetX
    this.y = evt.offsetY
  }

  getPositions() {
    return {
      x1: getPixelPosition(this.startX),
      y1: getPixelPosition(this.startY),
      x2: getPixelPosition(this.x),
      y2: getPixelPosition(this.y)
    }
  }

  coords(xc, yc, x, y) {
    return [
      [xc + x, yc + y],
      [xc - x, yc - y],
      [xc + x, yc - y],
      [xc - x, yc + y],
    ]
  }

  midpointEllipse(callback) {
    const { x1, y1, x2, y2 } = this.getPositions()

    /*
      a = horizontal radius
      b = vertical radius
    */
    let a = Math.round(Math.abs(x2 - x1) / 2),
        b = Math.round(Math.abs(y2 - y1) / 2)

    let xc = Math.min(x1, x2) + a,
        yc = Math.min(y1, y2) + b

    let a2 = a * a,
        b2 = b * b

    let twoa2 = 2 * a2,
        twob2 = 2 * b2

    let p
    let x = 0
    let y = b
    let px = 0
    let py = twoa2 * y

    /* Plot the initial point in each quadrant. */
    callback(this.coords(xc, yc, x, y))

    /* Region 1 */
    p = Math.round (b2 - (a2 * b) + (0.25 * a2))
    while (px < py) {
      x++
      px += twob2

      if (p < 0) {
        p += b2 + px
      }
      else {
        y--
        py -= twoa2
        p += b2 + px - py
      }

      callback(this.coords(xc, yc, x, y))
    }

    /* Region 2 */
    p = Math.round (b2 * (x+0.5) * (x+0.5) + a2 * (y-1) * (y-1) - a2 * b2)

    while (y > 0) {
      y--
      py -= twoa2

      if (p > 0) {
        p += a2 - py
      }
      else {
        x++
        px += twob2
        p += a2 - py + px
      }

      callback(this.coords(xc, yc, x, y))
    }
  }

  mouseUp(evt) {
    this.midpointEllipse(coords => {
      for (let [x, y] of coords) {
        this.project.currentFrame.setPixel(x, y, this.project.color)
      }
    })

    this.reset()
  }

  render(ctx) {
    if (this.startX && this.startY && this.x && this.y) {
      ctx.fillStyle = hexToRgba(this.project.color, 0.5)

      this.midpointEllipse(coords => {
        for (let [x, y] of coords) {
          ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE)
        }
      })
    }
  }
}

export default new Ellipse()