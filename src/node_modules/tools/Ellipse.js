import Tool from './Tool'

import { PIXEL_SIZE } from 'config/constants'

import { get } from 'svelte/store'

import { project } from 'store'

import { getPixelPosition, hexToRgba } from 'lib'

class Ellipse extends Tool {
  constructor() {
    super()

    this.cursor = 'crosshair'

    this.name = 'ellipse'
  }

  coords(xc, yc, x, y) {
    return [
      [xc + x, yc + y],
      [xc - x, yc - y],
      [xc + x, yc - y],
      [xc - x, yc + y],
    ]
  }

  midpointEllipse(callback) {
    const { x1, y1, x2, y2 } = this.getPositions()

    /*
      a = horizontal radius
      b = vertical radius
    */
    let a = Math.round(Math.abs(x2 - x1) / 2),
        b = Math.round(Math.abs(y2 - y1) / 2)

    let xc = Math.min(x1, x2) + a,
        yc = Math.min(y1, y2) + b

    let a2 = a * a,
        b2 = b * b

    let twoa2 = 2 * a2,
        twob2 = 2 * b2

    let p
    let x = 0
    let y = b
    let px = 0
    let py = twoa2 * y

    /* Plot the initial point in each quadrant. */
    callback(this.coords(xc, yc, x, y))

    /* Region 1 */
    p = Math.round (b2 - (a2 * b) + (0.25 * a2))
    while (px < py) {
      x++
      px += twob2

      if (p < 0) {
        p += b2 + px
      }
      else {
        y--
        py -= twoa2
        p += b2 + px - py
      }

      callback(this.coords(xc, yc, x, y))
    }

    /* Region 2 */
    p = Math.round (b2 * (x+0.5) * (x+0.5) + a2 * (y-1) * (y-1) - a2 * b2)

    while (y > 0) {
      y--
      py -= twoa2

      if (p > 0) {
        p += a2 - py
      }
      else {
        x++
        px += twob2
        p += a2 - py + px
      }

      callback(this.coords(xc, yc, x, y))
    }
  }

  mouseUp(evt) {
    if (!this.x1 || !this.y1) return false

    const proj = get(project)

    this.midpointEllipse(coords => {
      for (let [x, y] of coords) {
        proj.currentFrame.setPixel(x, y, proj.color)
      }
    })

    super.mouseUp(evt)
  }

  render(ctx) {
    if (this.x1 && this.y1 && this.x2 && this.y2) {
      ctx.fillStyle = hexToRgba(get(project).color, 0.5)

      this.midpointEllipse(coords => {
        for (let [x, y] of coords) {
          ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE)
        }
      })
    }
  }
}

export default new Ellipse()