import Tool from './Tool'

import { get } from 'svelte/store'

import { project, store } from 'store'

import { RESOLUTION, PIXEL_SIZE } from 'config/constants'

import KEYMAP from 'config/keymap'

import { MoveLayers } from 'commands'

import { TextLayer } from 'models'

import { characters } from 'text'

const HEIGHT = 8 * PIXEL_SIZE,
     PADDING = PIXEL_SIZE / 2

const SPACE = 1

class Text extends Tool {
  constructor() {
    super()

    this.cursor = 'text'

    this.name = 'text'

    this.cursorIndex = 0
  }

  mouseDown(evt) {
    const frame = get(project).currentFrame

    // Clicking on current text layer?
    for (let id of frame.layerIds) {
      const layer = frame.layers[id]

      if (layer.klass === 'TextLayer' && layer.withinBounds(evt)) {
        // console.log('in bounds!', layer)

        // store.update({ hoveringIds: [layer.id] })

        this.cursorIndex = 0

        this.textLayer = layer

        return true
      }
    }

    // super.mouseDown(evt)

    // const { x1, y1 } = this.getOrigin()

    // let [layer] = get(project).currentFrame.addLayers({ layers: [new TextLayer({ _x: x1 * PIXEL_SIZE, _y: y1 * PIXEL_SIZE })] })

    // this.cursorIndex = 0

    // this.textLayer = layer
  }

  mouseMove() { return false }

  mouseUp() { return false }

  keydown(evt) {
    evt.preventDefault()

    // console.log(evt.keyCode, evt.key)

    // if (evt.metaKey || evt.ctrlKey) return false

    let char = characters[evt.key]

    if (this.textLayer) this.textLayer.updateBounds()

    if (char) {
      this.textLayer.chars.push(char)

      this.cursorIndex++
    }
    else if (evt.key === 'Escape') {
      this.textLayer = null
    }
    else if (evt.key === 'Enter') {
      this.textLayer = null
    }
    else if (evt.key === 'Backspace') {
      if (evt.metaKey || evt.ctrlKey) {
        this.textLayer.chars = []

        this.cursorIndex = 0
      }
      else {
        this.textLayer.chars = this.textLayer.chars.slice(0, -1)

        this.cursorIndex--
      }
    }

    get(project).update()

    return true
  }

  commit() {

  }

  getOrigin() {
    const x1 = Math.round((this.x1 + PADDING / 2) / PIXEL_SIZE),
          y1 = Math.round((this.y1 - HEIGHT  / 2) / PIXEL_SIZE)

    return { x1, y1 }
  }

  get width() {
    let width = 0

    for (let char of this.textLayer.chars) {
      width += char.width + SPACE
    }

    return width
  }

  render(ctx) {
    // console.log('iyaa', store)
    // console.log('yo', this.textLayer)
    if (this.textLayer) {
      const { x1, y1 } = this.getOrigin()

      // Text box outline
      ctx.lineWidth = 1
      ctx.strokeStyle = '#63B3ED' // tailwind blue 400

      ctx.strokeRect(
        x1 * PIXEL_SIZE - PADDING,
        (y1 - 1) * PIXEL_SIZE - PADDING,
        this.width * PIXEL_SIZE + 2 * PADDING, // + this.width
        HEIGHT + 2 * PADDING
      )

      const cursorX = [...this.textLayer.chars].slice(0, this.cursorIndex).reduce((width, char) => width + char.width + SPACE, 0)

      // Cursor â€” every 650ms
      if (Math.floor(new Date().getTime() / 650) % 2 === 0) {
        ctx.fillStyle = '#4A5568' // tailwind 700

        ctx.fillRect((cursorX + x1) * PIXEL_SIZE, (y1 - 1) * PIXEL_SIZE, 1, HEIGHT)
      }

      // Woo
    }
  }
}

export default new Text()