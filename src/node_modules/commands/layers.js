import { get } from 'svelte/store'

import { store, project } from 'store'

import Layer from 'models/Layer'

import { getLayer } from './utils'

import Command from './Command'

/* Add & delete layers */

const addLayer = (frame, layer) => {
  const newLayer = new Layer(layer)

  frame.layers[newLayer.id] = newLayer

  frame.layerIds = [ newLayer.id, ...frame.layerIds ]

  // This needs handling elsewhere
  frame.layerId = Math.max(...frame.layerIds, 0) + 1

  // This is a nasty side-effect
  store.update({ activeLayerIds: [layer.id] })

  return newLayer
}

const deleteLayer = (frame, id) => {
  frame.layerIds = frame.layerIds.filter(layerId => layerId !== id)

  frame.layerId = Math.max(...frame.layerIds, 0) + 1

  delete frame.layers[id]

  store.update({ activeLayerIds: [] })
}

class AddLayer extends Command {
  static perform(frame, props = {}) {
    const id = frame.layerId++

    const layer = addLayer(frame, { ...props, id })

    this.push('AddLayer', {
      layer: Layer.duplicate(layer),
      frameId: frame.id
    })

    return layer
  }

  static undo({ layer, frameId }) {
    const frame = get(project).frames[frameId]

    deleteLayer(frame, layer.id)

    store.update(state => ({
      activeLayerIds:  [...state.activeLayerIds].filter(layerId => layerId !== id)
    }))
  }

  static redo({ frameId, layer }) {
    const frame = get(project).frames[frameId]

    return addLayer(frame, layer)
  }
}

class AddLayers extends Command {
  static perform({ frameId, layers = {} }) {
    const frame = get(project).frames[frameId]

    const newLayers = frame.addLayers({ layers })

    store.update({ activeLayerIds: layers.map(layer => layer.id) })

    return this.push('AddLayers', { frameId, layers: newLayers })
  }

  static undo({ frameId, layers }) {
    const frame = get(project).frames[frameId]

    const layerIds = layers.map(layer => layer.id)

    frame.deleteLayers({ layerIds })

    // Whether filtering the IDs vs. setting them to empty is necessary IDK
    return store.update(state => ({
      activeLayerIds:  [...state.activeLayerIds].filter(id => !layerIds.includes(id))
    }))
  }

  static redo({ frameId, layers }) {
    const frame = get(project).frames[frameId]

    frame.addLayers({ layers })

    return store.update({ activeLayerIds: layers.map(layer => layer.id) })
  }
}

class DeleteLayers extends Command {
  static perform({ frameId, layerIds }) {
    const frame = get(project).frames[frameId]

    const layers = layerIds.map(id => frame.layers[id])

    frame.deleteLayers({ layerIds })

    store.update({ activeLayerIds: [] })

    return this.push('DeleteLayers', { frameId, layers })
  }

  static undo({ frameId, layers }) {
    const frame = get(project).frames[frameId]

    frame.addLayers({ layers })

    return store.update({ activeLayerIds: layers.map(layer => layer.id) })
  }

  static redo({ frameId, layers }) {
    const frame = get(project).frames[frameId]

    frame.deleteLayers({ layerIds: layers.map(layer => layer.id) })

    return store.update({ activeLayerIds: [] })
  }
}

/* End add & delete layers */

/* Move layers */


const moveLayers = ({ frameId, layerIds, dx, dy, direction }) => {
  const frame = get(project).frames[frameId]

  for (let id of layerIds) {
    const layer = frame.layers[id]

    layer._x += (dx * direction)
    layer._y += (dy * direction)
  }

  return true
}


// Doesn't actually move layers in the perform â€” leave that up to the tool so it can happen in real-time.
class MoveLayers extends Command {
  static perform({ frameId, layerIds, dx, dy }) {
    return this.push('MoveLayers', { frameId, layerIds, dx, dy })
  }

  static undo(params) {
    return moveLayers({ ...params, direction: -1 })
  }

  static redo(params) {
    return moveLayers({ ...params, direction: 1 })
  }
}

/* End move */

/* Merge layers */

const sortByIndex = arr => (a, b) => arr.indexOf(b) - arr.indexOf(a)

const mergeLayers = (frame, layerIds) => {
  const [firstId, ...mergingIds] = layerIds.sort(sortByIndex(frame.layerIds))

  const firstLayer = frame.layers[firstId]

  for (let id of mergingIds) {
    firstLayer.merge(frame.layers[id])

    deleteLayer(frame, id)
  }

  firstLayer.updateBounds()

  return store.update({ activeLayerIds: [firstLayer.id] })
}

class MergeLayers extends Command {
  static perform({ frameId, layerIds }) {
    // Need 2 or more layers to merge!
    if (layerIds.length < 2) return false

    const frame = get(project).frames[frameId]

    this.push('MergeLayers', {
      frameId,
      layers: layerIds.map(id => Layer.duplicate(frame.layers[id]))
    })

    return mergeLayers(frame, layerIds)
  }

  static undo({ frameId, layers }) {
    const frame = get(project).frames[frameId]

    for (let layer of layers) {
      frame.layers[layer.id] = new Layer(layer)
    }

    const layerIds = layers.map(layer => layer.id)

    frame.layerIds = [...new Set([ ...layerIds, ...frame.layerIds ])]

    store.update({ activeLayerIds: layerIds })
  }

  static redo({ frameId, layers }) {
    const frame = get(project).frames[frameId]

    const layerIds = layers.map(layer => layer.id)

    return mergeLayers(frame, layerIds)
  }
}

/* End merge layers */

// Group layers
// Sort layers

export {
  AddLayer,
  AddLayers,
  DeleteLayers,
  MoveLayers,
  MergeLayers
}

