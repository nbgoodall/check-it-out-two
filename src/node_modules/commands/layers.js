import { get } from 'svelte/store'

import { store, project } from 'store'

import Layer from 'models/Layer'

import Command from './Command'

/* Add & delete layers */

const addLayer = (frame, layer) => {
  const newLayer = new Layer(layer)

  frame.layers[newLayer.id] = newLayer

  frame.layerIds = [ newLayer.id, ...frame.layerIds ]

  // This needs handling elsewhere
  frame.layerId = Math.max(...frame.layerIds, 0) + 1

  // This is a nasty side-effect
  store.update({ activeLayerIds: [layer.id] })

  return newLayer
}

const deleteLayer = (frame, id) => {
  frame.layerIds = frame.layerIds.filter(layerId => layerId !== id)

  frame.layerId = Math.max(...frame.layerIds, 0) + 1

  delete frame.layers[id]

  store.update({ activeLayerIds: [] })
}

class AddLayer extends Command {
  static perform(frame, props = {}) {
    const id = frame.layerId++

    const layer = addLayer(frame, { ...props, id })

    this.push('AddLayer', {
      layer: Layer.duplicate(layer),
      frameId: frame.id
    })

    return layer
  }

  static undo({ layer, frameId }) {
    const frame = get(project).frames[frameId]

    deleteLayer(frame, layer.id)

    store.update(state => ({
      activeLayerIds:  [...state.activeLayerIds].filter(layerId => layerId !== id)
    }))
  }

  static redo({ frameId, layer }) {
    const frame = get(project).frames[frameId]

    return addLayer(frame, layer)
  }
}

class AddLayers extends Command {
  static perform({ frameId, layers = {} }) {
    const frame = get(project).frames[frameId]

    const newLayers = frame.addLayers({ layers })

    store.update({ activeLayerIds: layers.map(layer => layer.id) })

    return this.push('AddLayers', { frameId, layers: newLayers })
  }

  static undo({ frameId, layers }) {
    const frame = get(project).frames[frameId]

    const layerIds = layers.map(layer => layer.id)

    frame.deleteLayers({ layerIds })

    // Whether filtering the IDs vs. setting them to empty is necessary IDK
    return store.update(state => ({
      activeLayerIds:  [...state.activeLayerIds].filter(id => !layerIds.includes(id))
    }))
  }

  static redo({ frameId, layers }) {
    const frame = get(project).frames[frameId]

    frame.addLayers({ layers })

    return store.update({ activeLayerIds: layers.map(layer => layer.id) })
  }
}

class DeleteLayers extends Command {
  static perform({ frameId, layerIds }) {
    const frame = get(project).frames[frameId]

    const orderedIds = frame.layerIds

    const layers = layerIds.map(id => frame.layers[id])

    const activeLayerIds = store.get('activeLayerIds')

    frame.deleteLayers({ layerIds })

    store.update({ activeLayerIds: [] })

    return this.push('DeleteLayers', { frameId, layers, activeLayerIds, orderedIds })
  }

  static undo({ frameId, layers, orderedIds, activeLayerIds }) {
    const frame = get(project).frames[frameId]

    frame.addLayers({ layers })

    frame.layerIds = orderedIds

    return store.update({ activeLayerIds })
  }

  static redo({ frameId, layers }) {
    const frame = get(project).frames[frameId]

    frame.deleteLayers({ layerIds: layers.map(layer => layer.id) })

    return store.update({ activeLayerIds: [] })
  }
}

/* End add & delete layers */

/* Move layers */


const moveLayers = ({ frameId, layerIds, dx, dy, direction }) => {
  const frame = get(project).frames[frameId]

  for (let id of layerIds) {
    const layer = frame.layers[id]

    layer._x += (dx * direction)
    layer._y += (dy * direction)
  }

  return true
}


// Doesn't actually move layers in the perform — leave that up to the tool so it can happen in real-time.
class MoveLayers extends Command {
  static perform({ frameId, layerIds, dx, dy }) {
    return this.push('MoveLayers', { frameId, layerIds, dx, dy })
  }

  static undo(params) {
    return moveLayers({ ...params, direction: -1 })
  }

  static redo(params) {
    return moveLayers({ ...params, direction: 1 })
  }
}

/* End move */

/* Merge layers */

const sortByIndex = arr => (a, b) => arr.indexOf(b) - arr.indexOf(a)

const mergeLayers = (frame, layerIds) => {
  const [firstId, ...mergingIds] = layerIds.sort(sortByIndex(frame.layerIds))

  const firstLayer = frame.layers[firstId]

  for (let id of mergingIds) {
    firstLayer.merge(frame.layers[id])

    deleteLayer(frame, id)
  }

  firstLayer.updateBounds()

  return store.update({ activeLayerIds: [firstLayer.id] })
}

class MergeLayers extends Command {
  static perform({ frameId, layerIds }) {
    // Need 2 or more layers to merge!
    if (layerIds.length < 2) return false

    const frame = get(project).frames[frameId]

    this.push('MergeLayers', {
      frameId,
      layers: layerIds.map(id => Layer.duplicate(frame.layers[id]))
    })

    return mergeLayers(frame, layerIds)
  }

  static undo({ frameId, layers }) {
    const frame = get(project).frames[frameId]

    for (let layer of layers) {
      // Layers need duplicating twice — once before storing (above), and here before undo-ing in case of a previous redo, which mutates layers
      frame.layers[layer.id] = Layer.duplicate(layer)
    }

    const layerIds = layers.map(layer => layer.id)

    frame.layerIds = [...new Set([ ...layerIds, ...frame.layerIds ])]

    store.update({ activeLayerIds: layerIds })
  }

  static redo({ frameId, layers }) {
    const frame = get(project).frames[frameId]

    const layerIds = layers.map(layer => layer.id)

    return mergeLayers(frame, layerIds)
  }
}

/* End merge layers */

/* Sort layers */

const sortLayers = ({ frame, ids, delta }) => {
  for (let id of ids) {
    let index = frame.layerIds.indexOf(id)

    let newPositions = frame.layerIds.splice(index, 1)

    frame.layerIds.splice(Math.max(0, index + delta), 0, ...newPositions)
  }
}

class SortLayers extends Command {
  static perform({ frame, layerIds, delta /* How far to move them, +ve or -ve */ }) {
    if (delta === 0) return false

    /* Not entirely sure what the thinking behind this is, but it works a treat */
    let ids = [...layerIds].sort((a, b) => delta * (frame.layerIds.indexOf(b) - frame.layerIds.indexOf(a)))

    let atEdge = ids.some(id =>
      (delta < 0 && id === frame.layerIds[0]) ||
      (delta > 0 && id === frame.layerIds[frame.layerIds.length - 1])
    )

    if (atEdge) return false

    sortLayers({ frame, ids, delta })

    this.push('SortLayers', { frameId: frame.id, ids, delta })
  }

  static undo({ frameId, ids, delta }) {
    const frame = get(project).frames[frameId]

    sortLayers({ frame, ids: [...ids].reverse(), delta: -delta })
  }

  static redo({ frameId, ids, delta }) {
    const frame = get(project).frames[frameId]

    sortLayers({ frame, ids, delta })
  }
}

/* End sort layers */

/* Colors layers */

// class ColorLayers extends Command {
//   static perform({ frame, layerIds, color }) {
//     if (delta === 0) return false

//     /* Not entirely sure what the thinking behind this is, but it works a treat */
//     let ids = [...layerIds].sort((a, b) => delta * (frame.layerIds.indexOf(b) - frame.layerIds.indexOf(a)))

//     let atEdge = ids.some(id =>
//       (delta < 0 && id === frame.layerIds[0]) ||
//       (delta > 0 && id === frame.layerIds[frame.layerIds.length - 1])
//     )

//     if (atEdge) return false

//     sortLayers({ frame, ids, delta })

//     this.push('ColorLayers', { frameId: frame.id, ids, delta })
//   }

//   static undo({ frameId, ids, delta }) {
//     const frame = get(project).frames[frameId]

//     sortLayers({ frame, ids: [...ids].reverse(), delta: -delta })
//   }

//   static redo({ frameId, ids, delta }) {
//     const frame = get(project).frames[frameId]

//     sortLayers({ frame, ids, delta })
//   }
// }

/* End color layers */

// Group layers

export {
  AddLayer,
  AddLayers,
  DeleteLayers,
  MoveLayers,
  MergeLayers,
  SortLayers
}

