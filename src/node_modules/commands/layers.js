import { get } from 'svelte/store'

import { store, project } from 'store'

import Layer from 'models/Layer'

import { getLayer } from './utils'

import Command from './Command'

/* Add & delete layers */

const addLayer = (frame, layer) => {
  const newLayer = new Layer(layer)

  frame.layers[newLayer.id] = newLayer

  frame.layerIds = [ newLayer.id, ...frame.layerIds ]

  // This needs handling elsewhere
  frame.layerId = Math.max(...frame.layerIds, 0) + 1

  // This is a nasty side-effect
  store.update({ activeLayerIds: [layer.id] })

  return newLayer
}

const deleteLayer = (frame, id) => {
  frame.layerIds = frame.layerIds.filter(layerId => layerId !== id)

  frame.layerId = Math.max(...frame.layerIds, 0) + 1

  delete frame.layers[id]

  store.update({ activeLayerIds: [] })
}

class AddLayer extends Command {
  static perform(frame, props = {}) {
    const id = frame.layerId++

    const layer = addLayer(frame, { ...props, id })

    this.push('AddLayer', {
      layer: Layer.duplicate(layer),
      frameId: frame.id
    })

    return layer
  }

  static undo({ layer, frameId }) {
    const frame = get(project).frames[frameId]

    deleteLayer(frame, layer.id)

    store.update(state => ({
      activeLayerIds:  [...state.activeLayerIds].filter(layerId => layerId !== id)
    }))
  }

  static redo({ frameId, layer }) {
    const frame = get(project).frames[frameId]

    return addLayer(frame, layer)
  }
}

class DeleteLayer extends Command {
  static perform(frame, id) {
    const oldLayer = frame.layers[id]

    this.push('DeleteLayer', {
      frameId: frame.id,
      layer: Layer.duplicate(oldLayer)
    })

    return deleteLayer(frame, id)
  }

  static undo({ layer, frameId }) {
    const frame = get(project).frames[frameId]

    return addLayer(frame, layer)
  }

  static redo({ layer, frameId }) {
    const frame = get(project).frames[frameId]

    return deleteLayer(frame, layer.id)
  }
}

/* End add & delete layers */

/* Move layer */

const moveLayer = ({ id, frameId, dx, dy, direction }) => {
  const layer = getLayer(frameId, id)

  layer._x += (dx * direction)
  layer._y += (dy * direction)

  return true
}

class MoveLayer extends Command {
  static perform({ id, frameId, dx, dy }) {
    return this.push('MoveLayer', { id, frameId, dx, dy })
  }

  static undo(params) {
    return moveLayer({ ...params, direction: -1 })
  }

  static redo(params) {
    return moveLayer({ ...params, direction: 1 })
  }
}

/* End move */

/* Merge layers */

const sortByIndex = arr => (a, b) => arr.indexOf(b) - arr.indexOf(a)

const mergeLayers = (frame, layerIds) => {
  const [firstId, ...mergingIds] = layerIds.sort(sortByIndex(frame.layerIds))

  const firstLayer = frame.layers[firstId]

  for (let id of mergingIds) {
    firstLayer.merge(frame.layers[id])

    deleteLayer(frame, id)
  }

  firstLayer.updateBounds()

  return store.update({ activeLayerIds: [firstLayer.id] })
}

class MergeLayers extends Command {
  static perform({ frameId, layerIds }) {
    // Need 2 or more layers to merge!
    if (layerIds.length < 2) return false

    const frame = get(project).frames[frameId]

    this.push('MergeLayers', {
      frameId,
      layers: layerIds.map(id => Layer.duplicate(frame.layers[id]))
    })

    return mergeLayers(frame, layerIds)
  }

  static undo({ frameId, layers }) {
    const frame = get(project).frames[frameId]

    for (let layer of layers) {
      frame.layers[layer.id] = new Layer(layer)
    }

    const layerIds = layers.map(layer => layer.id)

    frame.layerIds = [...new Set([ ...layerIds, ...frame.layerIds ])]

    store.update({ activeLayerIds: layerIds })
  }

  static redo({ frameId, layers }) {
    const frame = get(project).frames[frameId]

    const layerIds = layers.map(layer => layer.id)

    return mergeLayers(frame, layerIds)
  }
}

/* End merge layers */

// Group layers
// Sort layers

export {
  AddLayer,
  DeleteLayer,
  MoveLayer,
  MergeLayers
}

