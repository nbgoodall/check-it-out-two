import { RESOLUTION, PIXEL_SIZE } from 'config/constants'

import { get } from 'svelte/store'

import { store, project } from 'store'

import Command from './Command'

import { AddLayer } from './layers'

import { getLayer } from './utils'


/* Draw pixels

  pixels = {
    [x]: {
      [y]: '#ABC123'
    }
  }
*/

// TODO: switch active frame if history happened in a diff frame...

const drawPixel = ({ layer, x, y, color }) => {
  if (layer.pixels[x]) {
    if (color === null || color === 'transparent') {
      delete layer.pixels[x][y]

      if (Object.keys(layer.pixels[x]).length <= 0) {
        delete layer.pixels[x]
      }
    }
    else {
      layer.pixels[x][y] = color
    }
  }
  else if (color && color !== 'transparent') {
    layer.pixels[x] = { [y]: color }
  }
}

const drawPixels = ({ layer, pixels, color /* For overrides */ }) => {
  for (let x in pixels) {
    for (let y in pixels[x]) {
      let _color = pixels[x][y]

      drawPixel({ layer, x, y, color: typeof color === 'undefined' ? _color : color })
    }
  }

  layer.updateBounds()

  get(project).updateColors()
}

const erasePixels = ({ ...args }) => drawPixels({ ...args, color: null })

const transformPixels = ({ layer, pixels, includeEmpty = true }) => {
  let oldPixels = {},
      newPixels = {}

  const dX = layer.x / PIXEL_SIZE,
        dY = layer.y / PIXEL_SIZE

  for (let x in pixels) {
    let nX = Number(x) - dX

    newPixels[nX] = {}

    for (let y in pixels[x]) {
      let nY = Number(y) - dY

      let oldValue = (layer.pixels[nX] || {})[nY] || null

      if (includeEmpty || oldValue !== null) {
        (oldPixels[nX] = oldPixels[nX] || {})[nY] = oldValue
      }

      newPixels[nX][nY] = pixels[x][y]
    }
  }

  return { newPixels, oldPixels }
}

class DrawPixels extends Command {
  static perform({ frame, pixels }) {
    if (store.get('eraseModifier')) {
      return ErasePixels.perform({ frame, pixels })
    }

    let [layerId, ...ids] = store.get('activeLayerIds')

    // Person has selected many layers â€” don't want to draw on all at once.. or do we?!
    if (ids.length > 0) return false

    // Layer exists!
    if (layerId) {
      const layer = frame.layers[layerId]

      const { newPixels, oldPixels } = transformPixels({ layer, pixels })

      drawPixels({ layer, pixels: newPixels })

      this.push('DrawPixels', { frameId: frame.id, layerId, newPixels, oldPixels })
    }
    // Drawing on a new layer
    else {
      AddLayer.perform(frame, { pixels })
    }
  }

  static undo({ frameId, layerId, oldPixels }) {
    const layer = getLayer(frameId, layerId)

    return drawPixels({ layer, pixels: oldPixels })
  }

  static redo({ frameId, layerId, newPixels }) {
    const layer = getLayer(frameId, layerId)

    return drawPixels({ layer, pixels: newPixels })
  }
}

/* End draw pixels */


/* Erase pixels

  Similar to DrawPixels, but works across layers...
*/

class ErasePixels extends Command {
  static perform({ frame, pixels }) {
    let layerPixels = {}

    for (let id of frame.layerIds) {
      let layer = frame.layers[id]

      const { oldPixels } = transformPixels({ layer, pixels, includeEmpty: false })

      if (Object.keys(oldPixels).length > 0) {
        erasePixels({ layer, pixels: oldPixels })

        layerPixels[id] = oldPixels
      }
    }

    if (Object.keys(layerPixels).length > 0) {
      this.push('ErasePixels', { frameId: frame.id, layerPixels })
    }
  }

  static undo({ frameId, layerPixels }) {
    const frame = get(project).frames[frameId]

    for (let layerId in layerPixels) {
      let layer = frame.layers[layerId]

      drawPixels({ layer, pixels: layerPixels[layerId] })
    }

    return true
  }

  static redo({ frameId, layerPixels }) {
    const frame = get(project).frames[frameId]

    for (let layerId in layerPixels) {
      let layer = frame.layers[layerId]

      erasePixels({ layer, pixels: layerPixels[layerId] })
    }

    return true
  }
}

// Undoing the slo-ish-mo fill effect would be EPIC :O
class FillPixels extends Command {}

export {
  DrawPixels,
  ErasePixels
}